# Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡

Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø±ÙˆÚ˜Ù‡:
â”œâ”€â”€ [.env](#_env)
â”œâ”€â”€ [config.py](#config_py)
â”œâ”€â”€ [main.py](#main_py)
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ [__init__.py](#database___init___py)
â”‚   â”œâ”€â”€ [connection.py](#database_connection_py)
â”‚   â”œâ”€â”€ [database_manager.py](#database_database_manager_py)
â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ [__init__.py](#database_migrations___init___py)
â”‚   â”‚   â””â”€â”€ [schema.py](#database_migrations_schema_py)
â”‚   â””â”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ [__init__.py](#database_models___init___py)
â”‚   â”‚   â”œâ”€â”€ [admin_review.py](#database_models_admin_review_py)
â”‚   â”‚   â”œâ”€â”€ [category.py](#database_models_category_py)
â”‚   â”‚   â”œâ”€â”€ [task.py](#database_models_task_py)
â”‚   â”‚   â”œâ”€â”€ [task_attachment.py](#database_models_task_attachment_py)
â”‚   â”‚   â”œâ”€â”€ [task_scores.py](#database_models_task_scores_py)
â”‚   â”‚   â”œâ”€â”€ [task_section_file.py](#database_models_task_section_file_py)
â”‚   â”‚   â”œâ”€â”€ [task_work_data.py](#database_models_task_work_data_py)
â”‚   â”‚   â””â”€â”€ [user.py](#database_models_user_py)
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ [__init__.py](#handlers___init___py)
â”‚   â”œâ”€â”€ [registration_handler.py](#handlers_registration_handler_py)
â”‚   â”œâ”€â”€ admin/
â”‚   â”‚   â”œâ”€â”€ [__init__.py](#handlers_admin___init___py)
â”‚   â”‚   â”œâ”€â”€ [category_handler.py](#handlers_admin_category_handler_py)
â”‚   â”‚   â”œâ”€â”€ [completed_tasks_handler.py](#handlers_admin_completed_tasks_handler_py)
â”‚   â”‚   â”œâ”€â”€ [daily_report_handler.py](#handlers_admin_daily_report_handler_py)
â”‚   â”‚   â”œâ”€â”€ [define_task_handler.py](#handlers_admin_define_task_handler_py)
â”‚   â”‚   â”œâ”€â”€ [edit_task_handler.py](#handlers_admin_edit_task_handler_py)
â”‚   â”‚   â”œâ”€â”€ [manage_tasks_handler.py](#handlers_admin_manage_tasks_handler_py)
â”‚   â”‚   â”œâ”€â”€ [menu_handler.py](#handlers_admin_menu_handler_py)
â”‚   â”‚   â”œâ”€â”€ [new_manage_tasks_handler.py](#handlers_admin_new_manage_tasks_handler_py)
â”‚   â”‚   â””â”€â”€ [user_management_handler.py](#handlers_admin_user_management_handler_py)
â”‚   â””â”€â”€ employee/
â”‚   â”‚   â”œâ”€â”€ [__init__.py](#handlers_employee___init___py)
â”‚   â”‚   â”œâ”€â”€ [employee_archive_handler.py](#handlers_employee_employee_archive_handler_py)
â”‚   â”‚   â”œâ”€â”€ [employee_task_handler.py](#handlers_employee_employee_task_handler_py)
â”‚   â”‚   â””â”€â”€ [employee_work_handler.py](#handlers_employee_employee_work_handler_py)
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ [__init__.py](#services___init___py)
â”‚   â”œâ”€â”€ [file_service.py](#services_file_service_py)
â”‚   â”œâ”€â”€ [review_service.py](#services_review_service_py)
â”‚   â”œâ”€â”€ [task_service.py](#services_task_service_py)
â”‚   â”œâ”€â”€ [user_service.py](#services_user_service_py)
â”‚   â””â”€â”€ [work_service.py](#services_work_service_py)
â””â”€â”€ utils/
â”‚   â”œâ”€â”€ [__init__.py](#utils___init___py)
â”‚   â”œâ”€â”€ [constants.py](#utils_constants_py)
â”‚   â”œâ”€â”€ [formatters.py](#utils_formatters_py)
â”‚   â”œâ”€â”€ [keyboards.py](#utils_keyboards_py)
â”‚   â””â”€â”€ [validators.py](#utils_validators_py)


================================================================================



<a id='_env'></a>
==================================================
# Ø¨Ø®Ø´ 1: .env
==================================================

# Bot Token
BOT_TOKEN=7941925450:AAF--AEfYrrLDFXUgCzTQP2tVr2H298LT1A

# Admin ID
ADMIN_ID=2138687434

# Employees (format: user_id:name,user_id:name)
EMPLOYEES=93543315:Ø§Ø­Ù…Ø¯ Ø±Ø¶Ø§ÛŒÛŒ,2138687434:Ø¹Ù„ÛŒ Ù…Ø¯ÛŒØ±ÛŒ

# Database
DB_FILE=task_bot.db

<a id='config_py'></a>
==================================================
# Ø¨Ø®Ø´ 2: config.py
==================================================

# config.py

import os
from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = os.getenv('BOT_TOKEN')
if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN Ø¯Ø± ÙØ§ÛŒÙ„ .env ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª!")

ADMIN_ID = 2138687434

DB_FILE = "task_bot.db"


<a id='database_connection_py'></a>
==================================================
# Ø¨Ø®Ø´ 3: database\connection.py
==================================================

# database/connection.py

import sqlite3
import os
from config import DB_FILE

# Ù…Ø³ÛŒØ± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¯Ø± Ø±ÛŒØ´Ù‡ Ù¾Ø±ÙˆÚ˜Ù‡
DB_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), DB_FILE)


def create_connection():
    """
    Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† ÛŒÚ© Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ SQLite
    
    Returns:
        sqlite3.Connection: Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÛŒØ§ None Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§
    """
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row  # Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¢Ø³Ø§Ù†â€ŒØªØ± Ø¨Ù‡ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§
        return conn
    except sqlite3.Error as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
        return None


<a id='database_database_manager_py'></a>
==================================================
# Ø¨Ø®Ø´ 4: database\database_manager.py
==================================================

# database/database_manager.py

import sqlite3
import os
import sys

# Ø§ÙØ²ÙˆØ¯Ù† Ù…Ø³ÛŒØ± Ø±ÛŒØ´Ù‡ Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ù‡ Ù…Ø³ÛŒØ± Ù¾Ø§ÛŒØªÙˆÙ†
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
try:
    from config import ADMIN_ID
except ImportError:
    print("Error: config.py not found or required variables are not defined.")
    sys.exit()

DB_NAME = "task_bot.db"
# Ù…Ø³ÛŒØ± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø±Ø§ Ø¯Ø± Ø±ÛŒØ´Ù‡ Ù¾Ø±ÙˆÚ˜Ù‡ Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒØ¯Ù‡Ø¯
DB_PATH = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')), DB_NAME)


def create_connection():
    """ÛŒÚ© Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ SQLite Ø¯Ø± Ù…Ø³ÛŒØ± Ù…Ø´Ø®Øµ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯."""
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH)
        return conn
    except sqlite3.Error as e:
        print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
    return conn


def setup_database():
    """Ø¬Ø¯Ø§ÙˆÙ„ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø±Ø§ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø§ÛŒØ¬Ø§Ø¯ Ùˆ Ø§Ø¯Ù…ÛŒÙ† Ø±Ø§ Ø«Ø¨Øª Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()

            # Ø¬Ø¯ÙˆÙ„ Users Ø¨Ø§ ÙÛŒÙ„Ø¯ is_employee
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS Users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER UNIQUE,
                    first_name TEXT,
                    last_name TEXT,
                    name TEXT NOT NULL,
                    phone_number TEXT,
                    role TEXT CHECK( role IN ('admin', 'employee', 'pending') ) NOT NULL DEFAULT 'pending',
                    is_employee INTEGER DEFAULT 0,
                    registration_date TEXT,
                    approved_date TEXT
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ Categories
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS Categories (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ Tasks Ø¨Ø§ ÙˆØ¶Ø¹ÛŒØª archived
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS Tasks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    description TEXT,
                    assigned_to_id INTEGER,
                    assigned_by_id INTEGER,
                    duration TEXT,
                    results TEXT,
                    importance INTEGER,
                    priority INTEGER,
                    status TEXT CHECK( status IN ('pending', 'in_progress', 'completed', 'on_hold', 'archived') ) NOT NULL DEFAULT 'pending',
                    creation_date TEXT,
                    completion_date TEXT,
                    category_id INTEGER,
                    FOREIGN KEY (assigned_to_id) REFERENCES Users (id),
                    FOREIGN KEY (assigned_by_id) REFERENCES Users (id),
                    FOREIGN KEY (category_id) REFERENCES Categories (id)
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ TaskAttachments
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS TaskAttachments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id INTEGER NOT NULL,
                    file_id TEXT NOT NULL,
                    file_type TEXT,
                    FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ TaskActivities
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS TaskActivities (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    task_id INTEGER NOT NULL,
                    start_time TEXT NOT NULL,
                    end_time TEXT,
                    FOREIGN KEY (user_id) REFERENCES Users (id),
                    FOREIGN KEY (task_id) REFERENCES Tasks (id)
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ TaskWorkData
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS TaskWorkData (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    data_type TEXT NOT NULL,
                    text_content TEXT,
                    file_id TEXT,
                    file_type TEXT,
                    timestamp TEXT,
                    FOREIGN KEY (task_id) REFERENCES Tasks (id),
                    FOREIGN KEY (user_id) REFERENCES Users (id)
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ TaskScores
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS TaskScores (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    self_score INTEGER,
                    timestamp TEXT,
                    FOREIGN KEY (task_id) REFERENCES Tasks (id),
                    FOREIGN KEY (user_id) REFERENCES Users (id)
                );
            """)

            # Ø¬Ø¯ÙˆÙ„ AdminReviews
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS AdminReviews (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    task_id INTEGER NOT NULL,
                    admin_id INTEGER NOT NULL,
                    review_type TEXT NOT NULL,
                    text_content TEXT,
                    file_id TEXT,
                    file_type TEXT,
                    admin_score INTEGER,
                    timestamp TEXT,
                    FOREIGN KEY (task_id) REFERENCES Tasks (id),
                    FOREIGN KEY (admin_id) REFERENCES Users (id)
                );
            """)

            conn.commit()

            # Ø«Ø¨Øª Ø§Ø¯Ù…ÛŒÙ†
            from datetime import datetime
            cursor.execute("""
                INSERT OR IGNORE INTO Users (telegram_id, name, role, is_employee, registration_date) 
                VALUES (?, ?, ?, ?, ?)
            """, (ADMIN_ID, "Ù…Ø¯ÛŒØ± Ø³ÛŒØ³ØªÙ…", "admin", 0, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))

            conn.commit()
            print("âœ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯.")
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
        finally:
            conn.close()


def register_user(telegram_id, first_name, last_name, phone_number=None):
    """Ø«Ø¨Øª Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    conn = create_connection()
    if conn:
        try:
            from datetime import datetime
            cursor = conn.cursor()
            full_name = f"{first_name} {last_name}".strip()

            cursor.execute("""
                INSERT OR IGNORE INTO Users (telegram_id, first_name, last_name, name, phone_number, role, registration_date) 
                VALUES (?, ?, ?, ?, ?, 'pending', ?)
            """, (
            telegram_id, first_name, last_name, full_name, phone_number, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))

            conn.commit()
            return True
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ú©Ø§Ø±Ø¨Ø±: {e}")
            return False
        finally:
            conn.close()
    return False


def get_user_by_telegram_id(telegram_id):
    """Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ telegram_id"""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Users WHERE telegram_id = ?", (telegram_id,))
            user = cursor.fetchone()
            return user
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±: {e}")
            return None
        finally:
            conn.close()
    return None


def get_all_pending_users():
    """Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯"""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, telegram_id, name, registration_date, is_employee 
                FROM Users 
                WHERE role = 'pending' OR (role = 'employee' AND is_employee = 0)
                ORDER BY registration_date DESC
            """)
            users = cursor.fetchall()
            return users
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: {e}")
            return []
        finally:
            conn.close()
    return []


def get_all_users():
    """Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª ØªÙ…Ø§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù†"""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, telegram_id, name, role, is_employee, registration_date 
                FROM Users 
                WHERE role != 'admin'
                ORDER BY registration_date DESC
            """)
            users = cursor.fetchall()
            return users
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: {e}")
            return []
        finally:
            conn.close()
    return []


def approve_employee(telegram_id):
    """ØªØ¨Ø¯ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    conn = create_connection()
    if conn:
        try:
            from datetime import datetime
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE Users 
                SET role = 'employee', is_employee = 1, approved_date = ?
                WHERE telegram_id = ?
            """, (datetime.now().strftime("%Y-%m-%d %H:%M:%S"), telegram_id))
            conn.commit()
            return True
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯: {e}")
            return False
        finally:
            conn.close()
    return False


def get_all_employees():
    """Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†"""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, telegram_id, name 
                FROM Users 
                WHERE is_employee = 1 AND role = 'employee'
                ORDER BY name
            """)
            employees = cursor.fetchall()
            return employees
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†: {e}")
            return []
        finally:
            conn.close()
    return []


def add_category_to_tasks():
    """Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø³ØªÙˆÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ù‡ Ø¬Ø¯ÙˆÙ„ Tasks - Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø²Ú¯Ø§Ø±ÛŒ Ø¨Ø§ Ú©Ø¯ Ù‚Ø¯ÛŒÙ…ÛŒ"""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()
            # Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ú©Ù‡ Ø³ØªÙˆÙ† ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ ÛŒØ§ Ù†Ù‡
            cursor.execute("PRAGMA table_info(Tasks)")
            columns = [column[1] for column in cursor.fetchall()]

            if 'category_id' not in columns:
                cursor.execute("ALTER TABLE Tasks ADD COLUMN category_id INTEGER")
                conn.commit()
                print("âœ… Ø³ØªÙˆÙ† category_id Ø¨Ù‡ Ø¬Ø¯ÙˆÙ„ Tasks Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯")
        except Exception as e:
            # Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø³ØªÙˆÙ† Ø§Ø² Ù‚Ø¨Ù„ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
            pass
        finally:
            conn.close()


def update_status_constraint():
    """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ constraint Ø¨Ø±Ø§ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª archived - Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø²Ú¯Ø§Ø±ÛŒ Ø¨Ø§ Ú©Ø¯ Ù‚Ø¯ÛŒÙ…ÛŒ"""
    conn = create_connection()
    if conn:
        try:
            cursor = conn.cursor()

            # Ú†Ú© Ú©Ù†ÛŒÙ… Ú©Ù‡ Ø¢ÛŒØ§ Ø¬Ø¯ÙˆÙ„ Ø§Ø² Ù‚Ø¨Ù„ archived Ø±Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
            cursor.execute("PRAGMA table_info(Tasks)")
            print("âœ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø§Ø² Ù‚Ø¨Ù„ ÙˆØ¶Ø¹ÛŒØª archived Ø±Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯")

        except Exception as e:
            print(f"â„¹ï¸ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø§Ø®ØªØ§Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³: {e}")
        finally:
            conn.close()


<a id='database___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 5: database\__init__.py
==================================================

# database/__init__.py

from database.connection import create_connection
from database.migrations.schema import setup_database, create_tables, seed_admin

__all__ = [
    'create_connection',
    'setup_database',
    'create_tables',
    'seed_admin'
]


<a id='database_migrations_schema_py'></a>
==================================================
# Ø¨Ø®Ø´ 6: database\migrations\schema.py
==================================================

# database/migrations/schema.py

from database.connection import create_connection
from config import ADMIN_ID
from datetime import datetime


def create_tables():
    """Ø§ÛŒØ¬Ø§Ø¯ ØªÙ…Ø§Ù… Ø¬Ø¯Ø§ÙˆÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    conn = create_connection()
    if not conn:
        return False
        
    try:
        cursor = conn.cursor()
        
        # Ø¬Ø¯ÙˆÙ„ Users
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS Users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER UNIQUE NOT NULL,
                first_name TEXT,
                last_name TEXT,
                name TEXT NOT NULL,
                phone_number TEXT,
                role TEXT CHECK( role IN ('admin', 'employee', 'pending') ) NOT NULL DEFAULT 'pending',
                is_employee INTEGER DEFAULT 0,
                registration_date TEXT,
                approved_date TEXT
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ Categories
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS Categories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ Tasks
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS Tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                description TEXT,
                assigned_to_id INTEGER,
                assigned_by_id INTEGER,
                duration TEXT,
                results TEXT,
                importance INTEGER,
                priority INTEGER,
                status TEXT CHECK( status IN ('pending', 'in_progress', 'completed', 'on_hold', 'archived') ) NOT NULL DEFAULT 'pending',
                creation_date TEXT,
                completion_date TEXT,
                category_id INTEGER,
                is_submitted INTEGER DEFAULT 0,
                is_finalized INTEGER DEFAULT 0,
                FOREIGN KEY (assigned_to_id) REFERENCES Users (id),
                FOREIGN KEY (assigned_by_id) REFERENCES Users (id),
                FOREIGN KEY (category_id) REFERENCES Categories (id)
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ TaskAttachments (ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¶Ù…ÛŒÙ…Ù‡ Ø§ØµÙ„ÛŒ Ú©Ø§Ø±)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS TaskAttachments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id INTEGER NOT NULL,
                file_id TEXT NOT NULL,
                file_type TEXT,
                FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ TaskSectionFiles (ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS TaskSectionFiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id INTEGER NOT NULL,
                section_type TEXT CHECK( section_type IN ('results', 'description') ) NOT NULL,
                file_id TEXT NOT NULL,
                file_type TEXT,
                FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ TaskActivities (ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS TaskActivities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                task_id INTEGER NOT NULL,
                start_time TEXT NOT NULL,
                end_time TEXT,
                FOREIGN KEY (user_id) REFERENCES Users (id),
                FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ TaskWorkData (Ø¯Ø§Ù†Ø´ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ØŒ Ù†ØªØ§ÛŒØ¬ Ú©Ø§Ø±Ù…Ù†Ø¯)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS TaskWorkData (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                data_type TEXT CHECK( data_type IN ('knowledge', 'suggestion', 'results') ) NOT NULL,
                text_content TEXT,
                file_id TEXT,
                file_type TEXT,
                timestamp TEXT,
                FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES Users (id)
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ TaskScores (Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø®ÙˆØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS TaskScores (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                self_score INTEGER,
                timestamp TEXT,
                FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES Users (id)
            );
        """)
        
        # Ø¬Ø¯ÙˆÙ„ AdminReviews (Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS AdminReviews (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id INTEGER NOT NULL,
                admin_id INTEGER NOT NULL,
                review_type TEXT CHECK( review_type IN ('opinion', 'positive', 'negative', 'suggestion', 'score') ) NOT NULL,
                text_content TEXT,
                file_id TEXT,
                file_type TEXT,
                admin_score INTEGER,
                timestamp TEXT,
                FOREIGN KEY (task_id) REFERENCES Tasks (id) ON DELETE CASCADE,
                FOREIGN KEY (admin_id) REFERENCES Users (id)
            );
        """)
        
        conn.commit()
        print("âœ… Ø¬Ø¯Ø§ÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù†Ø¯")
        return True
        
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¬Ø¯Ø§ÙˆÙ„: {e}")
        return False
    finally:
        conn.close()


def seed_admin():
    """Ø«Ø¨Øª Ø§Ø¯Ù…ÛŒÙ† Ø§ÙˆÙ„ÛŒÙ‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    conn = create_connection()
    if not conn:
        return False
        
    try:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT OR IGNORE INTO Users (telegram_id, name, role, is_employee, registration_date) 
            VALUES (?, ?, ?, ?, ?)
        """, (ADMIN_ID, "Ù…Ø¯ÛŒØ± Ø³ÛŒØ³ØªÙ…", "admin", 0, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        
        conn.commit()
        print("âœ… Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯")
        return True
        
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø¯Ù…ÛŒÙ†: {e}")
        return False
    finally:
        conn.close()


def setup_database():
    """Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    print("ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³...")
    if create_tables():
        seed_admin()
        print("âœ… Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯")
        return True
    return False


<a id='database_migrations___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 7: database\migrations\__init__.py
==================================================

# database/migrations/__init__.py

from database.migrations.schema import setup_database, create_tables, seed_admin

__all__ = ['setup_database', 'create_tables', 'seed_admin']


<a id='database_models_admin_review_py'></a>
==================================================
# Ø¨Ø®Ø´ 8: database\models\admin_review.py
==================================================

# database/models/admin_review.py

from database.connection import create_connection
from datetime import datetime
from typing import Optional, List, Dict, Any


class AdminReviewModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ AdminReviews"""
    
    @staticmethod
    def create(task_id: int, admin_id: int, review_type: str,
               text_content: Optional[str] = None, file_id: Optional[str] = None,
               file_type: Optional[str] = None, admin_score: Optional[int] = None) -> Optional[int]:
        """Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            cursor.execute("""
                INSERT INTO AdminReviews 
                (task_id, admin_id, review_type, text_content, file_id, file_type, admin_score, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (task_id, admin_id, review_type, text_content, file_id, file_type, admin_score, timestamp))
            
            review_id = cursor.lastrowid
            conn.commit()
            return review_id
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_task(task_id: int, review_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            
            if review_type:
                cursor.execute("""
                    SELECT * FROM AdminReviews 
                    WHERE task_id = ? AND review_type = ?
                    ORDER BY timestamp DESC
                """, (task_id, review_type))
            else:
                cursor.execute("""
                    SELECT * FROM AdminReviews 
                    WHERE task_id = ?
                    ORDER BY timestamp DESC
                """, (task_id,))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø¸Ø±Ø§Øª: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def get_latest_score(task_id: int) -> Optional[int]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø®Ø±ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø² Ø§Ø¯Ù…ÛŒÙ†"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT admin_score FROM AdminReviews 
                WHERE task_id = ? AND review_type = 'score' AND admin_score IS NOT NULL
                ORDER BY timestamp DESC
                LIMIT 1
            """, (task_id,))
            
            row = cursor.fetchone()
            if row:
                return row[0]
            return None
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø²: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def delete_by_task(task_id: int) -> bool:
        """Ø­Ø°Ù ØªÙ…Ø§Ù… Ù†Ø¸Ø±Ø§Øª ÛŒÚ© Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM AdminReviews WHERE task_id = ?", (task_id,))
            conn.commit()
            return True
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù†Ø¸Ø±Ø§Øª: {e}")
            return False
        finally:
            conn.close()


<a id='database_models_category_py'></a>
==================================================
# Ø¨Ø®Ø´ 9: database\models\category.py
==================================================

# database/models/category.py

from database.connection import create_connection
from typing import Optional, List, Dict, Any


class CategoryModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ Categories"""
    
    @staticmethod
    def create(name: str) -> Optional[int]:
        """Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("INSERT INTO Categories (name) VALUES (?)", (name,))
            category_id = cursor.lastrowid
            conn.commit()
            return category_id
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_id(category_id: int) -> Optional[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ id"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Categories WHERE id = ?", (category_id,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_name(name: str) -> Optional[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ Ù†Ø§Ù…"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Categories WHERE name = ?", (name,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_all() -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§"""
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Categories ORDER BY name")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def update(category_id: int, name: str) -> bool:
        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("UPDATE Categories SET name = ? WHERE id = ?", (name, category_id))
            conn.commit()
            return cursor.rowcount > 0
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {e}")
            return False
        finally:
            conn.close()
    
    @staticmethod
    def delete(category_id: int) -> bool:
        """Ø­Ø°Ù Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM Categories WHERE id = ?", (category_id,))
            conn.commit()
            return cursor.rowcount > 0
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {e}")
            return False
        finally:
            conn.close()


<a id='database_models_task_py'></a>
==================================================
# Ø¨Ø®Ø´ 10: database\models\task.py
==================================================

# database/models/task.py

from database.connection import create_connection
from datetime import datetime
from typing import Optional, List, Dict, Any


class TaskModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ Tasks"""

    @staticmethod
    def create(**kwargs) -> Optional[int]:
        """
        Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø± Ø¬Ø¯ÛŒØ¯

        Args:
            **kwargs: ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ú©Ø§Ø±

        Returns:
            int: task_id ÛŒØ§ None Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§
        """
        conn = create_connection()
        if not conn:
            return None

        try:
            cursor = conn.cursor()

            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙÛŒÙ„Ø¯Ù‡Ø§
            title = kwargs.get('title')
            description = kwargs.get('description')
            assigned_to_id = kwargs.get('assigned_to_id')
            assigned_by_id = kwargs.get('assigned_by_id')
            duration = kwargs.get('duration')
            results = kwargs.get('results')
            importance = kwargs.get('importance')
            priority = kwargs.get('priority')
            category_id = kwargs.get('category_id')
            status = kwargs.get('status', 'pending')
            creation_date = kwargs.get('creation_date', datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

            cursor.execute("""
                INSERT INTO Tasks 
                (title, description, assigned_to_id, assigned_by_id, duration, results, 
                 importance, priority, category_id, status, creation_date)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (title, description, assigned_to_id, assigned_by_id, duration, results,
                  importance, priority, category_id, status, creation_date))

            task_id = cursor.lastrowid
            conn.commit()

            print(f"âœ… Ú©Ø§Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯ - ID: {task_id}, ØªØ®ØµÛŒØµ Ø¨Ù‡: {assigned_to_id}")

            return task_id

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±: {e}")
            return None
        finally:
            conn.close()

    @staticmethod
    def get_by_id(task_id: int) -> Optional[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø± Ø¨Ø§ id"""
        conn = create_connection()
        if not conn:
            return None

        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Tasks WHERE id = ?", (task_id,))
            row = cursor.fetchone()

            if row:
                return dict(row)
            return None

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±: {e}")
            return None
        finally:
            conn.close()

    @staticmethod
    def get_with_details(task_id: int) -> Optional[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø± Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ù…Ù„"""
        conn = create_connection()
        if not conn:
            return None

        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT t.*, 
                       u1.name as assigned_to_name,
                       u2.name as assigned_by_name,
                       c.name as category_name
                FROM Tasks t
                LEFT JOIN Users u1 ON t.assigned_to_id = u1.id
                LEFT JOIN Users u2 ON t.assigned_by_id = u2.id
                LEFT JOIN Categories c ON t.category_id = c.id
                WHERE t.id = ?
            """, (task_id,))
            row = cursor.fetchone()

            if row:
                return dict(row)
            return None

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø±: {e}")
            return None
        finally:
            conn.close()

    @staticmethod
    def get_by_employee(employee_id: int, status: Optional[str] = None) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯"""
        conn = create_connection()
        if not conn:
            return []

        try:
            cursor = conn.cursor()

            if status:
                cursor.execute("""
                    SELECT t.*, c.name as category_name
                    FROM Tasks t
                    LEFT JOIN Categories c ON t.category_id = c.id
                    WHERE t.assigned_to_id = ? AND t.status = ?
                    ORDER BY t.creation_date DESC
                """, (employee_id, status))
            else:
                cursor.execute("""
                    SELECT t.*, c.name as category_name
                    FROM Tasks t
                    LEFT JOIN Categories c ON t.category_id = c.id
                    WHERE t.assigned_to_id = ?
                    ORDER BY t.creation_date DESC
                """, (employee_id,))

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯: {e}")
            return []
        finally:
            conn.close()

    @staticmethod
    def get_by_status(status: str) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ Ø¨Ø§ ÙˆØ¶Ø¹ÛŒØª Ø®Ø§Øµ"""
        conn = create_connection()
        if not conn:
            return []

        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT t.*, u.name as employee_name, c.name as category_name
                FROM Tasks t
                LEFT JOIN Users u ON t.assigned_to_id = u.id
                LEFT JOIN Categories c ON t.category_id = c.id
                WHERE t.status = ?
                ORDER BY t.creation_date DESC
            """, (status,))

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§: {e}")
            return []
        finally:
            conn.close()

    @staticmethod
    def get_completed_submitted() -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡"""
        conn = create_connection()
        if not conn:
            return []

        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT t.*, u.name as employee_name
                FROM Tasks t
                LEFT JOIN Users u ON t.assigned_to_id = u.id
                WHERE t.status = 'completed' AND t.is_submitted = 1 AND t.is_finalized = 0
                ORDER BY t.completion_date DESC
            """)

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡: {e}")
            return []
        finally:
            conn.close()

    @staticmethod
    def get_archived() -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡"""
        conn = create_connection()
        if not conn:
            return []

        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT t.*, u.name as employee_name
                FROM Tasks t
                LEFT JOIN Users u ON t.assigned_to_id = u.id
                WHERE t.is_finalized = 1
                ORDER BY t.completion_date DESC
            """)

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ: {e}")
            return []
        finally:
            conn.close()

    @staticmethod
    def update_status(task_id: int, status: str) -> bool:
        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()
            cursor.execute("UPDATE Tasks SET status = ? WHERE id = ?", (status, task_id))
            conn.commit()
            return cursor.rowcount > 0

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def mark_as_submitted(task_id: int) -> bool:
        """Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ú©Ø§Ø± Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡"""
        conn = create_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()
            completion_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            cursor.execute("""
                UPDATE Tasks 
                SET status = 'completed', is_submitted = 1, completion_date = ?
                WHERE id = ?
            """, (completion_date, task_id))
            conn.commit()
            return cursor.rowcount > 0

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø±: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def mark_as_finalized(task_id: int) -> bool:
        """Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ú©Ø§Ø± Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØªÙ‡"""
        conn = create_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()
            cursor.execute("UPDATE Tasks SET is_finalized = 1 WHERE id = ?", (task_id,))
            conn.commit()
            return cursor.rowcount > 0

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø±: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def update(task_id: int, **kwargs) -> bool:
        """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()

            fields = []
            values = []

            for key, value in kwargs.items():
                fields.append(f"{key} = ?")
                values.append(value)

            if not fields:
                return False

            values.append(task_id)
            query = f"UPDATE Tasks SET {', '.join(fields)} WHERE id = ?"

            cursor.execute(query, values)
            conn.commit()
            return cursor.rowcount > 0

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def delete(task_id: int) -> bool:
        """Ø­Ø°Ù Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM Tasks WHERE id = ?", (task_id,))
            conn.commit()
            return cursor.rowcount > 0

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±: {e}")
            return False
        finally:
            conn.close()

<a id='database_models_task_attachment_py'></a>
==================================================
# Ø¨Ø®Ø´ 11: database\models\task_attachment.py
==================================================

# database/models/task_attachment.py

from database.connection import create_connection
from typing import Optional, List, Dict, Any


class TaskAttachmentModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ TaskAttachments"""
    
    @staticmethod
    def create(task_id: int, file_id: str, file_type: str) -> Optional[int]:
        """Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø¶Ù…ÛŒÙ…Ù‡"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO TaskAttachments (task_id, file_id, file_type)
                VALUES (?, ?, ?)
            """, (task_id, file_id, file_type))
            
            attachment_id = cursor.lastrowid
            conn.commit()
            return attachment_id
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø¶Ù…ÛŒÙ…Ù‡: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_task(task_id: int) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¶Ù…ÛŒÙ…Ù‡ ÛŒÚ© Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT * FROM TaskAttachments WHERE task_id = ?
            """, (task_id,))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def delete_by_task(task_id: int) -> bool:
        """Ø­Ø°Ù ØªÙ…Ø§Ù… ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¶Ù…ÛŒÙ…Ù‡ ÛŒÚ© Ú©Ø§Ø±"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM TaskAttachments WHERE task_id = ?", (task_id,))
            conn.commit()
            return True
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ÙØ§ÛŒÙ„â€ŒÙ‡Ø§: {e}")
            return False
        finally:
            conn.close()
    
    @staticmethod
    def delete(attachment_id: int) -> bool:
        """Ø­Ø°Ù ÛŒÚ© ÙØ§ÛŒÙ„ Ø¶Ù…ÛŒÙ…Ù‡"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM TaskAttachments WHERE id = ?", (attachment_id,))
            conn.commit()
            return cursor.rowcount > 0
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ÙØ§ÛŒÙ„: {e}")
            return False
        finally:
            conn.close()


<a id='database_models_task_scores_py'></a>
==================================================
# Ø¨Ø®Ø´ 12: database\models\task_scores.py
==================================================

# database/models/task_scores.py

from database.connection import create_connection
from datetime import datetime
from typing import Optional, Dict, Any


class TaskScoresModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ TaskScores (Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯)"""

    @staticmethod
    def create_or_update(task_id: int, user_id: int, self_score: int) -> Optional[int]:
        """
        Ø§ÛŒØ¬Ø§Ø¯ ÛŒØ§ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
            self_score: Ø§Ù…ØªÛŒØ§Ø² (1-10)

        Returns:
            score_id ÛŒØ§ None
        """
        conn = create_connection()
        if not conn:
            return None

        try:
            cursor = conn.cursor()
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø§Ù…ØªÛŒØ§Ø² Ù‚Ø¨Ù„ÛŒ
            cursor.execute("""
                SELECT id FROM TaskScores 
                WHERE task_id = ? AND user_id = ?
            """, (task_id, user_id))

            existing = cursor.fetchone()

            if existing:
                # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù…ØªÛŒØ§Ø² Ù‚Ø¨Ù„ÛŒ
                cursor.execute("""
                    UPDATE TaskScores 
                    SET self_score = ?, timestamp = ?
                    WHERE task_id = ? AND user_id = ?
                """, (self_score, timestamp, task_id, user_id))
                score_id = existing['id']
            else:
                # Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù…ØªÛŒØ§Ø² Ø¬Ø¯ÛŒØ¯
                cursor.execute("""
                    INSERT INTO TaskScores 
                    (task_id, user_id, self_score, timestamp)
                    VALUES (?, ?, ?, ?)
                """, (task_id, user_id, self_score, timestamp))
                score_id = cursor.lastrowid

            conn.commit()
            return score_id

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø²: {e}")
            return None
        finally:
            conn.close()

    @staticmethod
    def get_by_task_and_user(task_id: int, user_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯

        Returns:
            dict Ø§Ù…ØªÛŒØ§Ø² ÛŒØ§ None
        """
        conn = create_connection()
        if not conn:
            return None

        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT * FROM TaskScores 
                WHERE task_id = ? AND user_id = ?
                ORDER BY timestamp DESC
                LIMIT 1
            """, (task_id, user_id))

            row = cursor.fetchone()
            return dict(row) if row else None

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø²: {e}")
            return None
        finally:
            conn.close()

    @staticmethod
    def get_all_by_task(task_id: int) -> list:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§ÛŒ Ø®ÙˆØ¯ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            Ù„ÛŒØ³Øª Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§
        """
        conn = create_connection()
        if not conn:
            return []

        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT ts.*, u.name as user_name
                FROM TaskScores ts
                JOIN Users u ON ts.user_id = u.id
                WHERE ts.task_id = ?
                ORDER BY ts.timestamp DESC
            """, (task_id,))

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§: {e}")
            return []
        finally:
            conn.close()

    @staticmethod
    def delete_by_task(task_id: int) -> bool:
        """
        Ø­Ø°Ù ØªÙ…Ø§Ù… Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        conn = create_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM TaskScores WHERE task_id = ?", (task_id,))
            conn.commit()
            return True

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§: {e}")
            return False
        finally:
            conn.close()

<a id='database_models_task_section_file_py'></a>
==================================================
# Ø¨Ø®Ø´ 13: database\models\task_section_file.py
==================================================

# database/models/task_section_file.py

from database.connection import create_connection
from typing import Optional, List, Dict, Any


class TaskSectionFileModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ TaskSectionFiles (ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†ØªØ§ÛŒØ¬ Ùˆ ØªÙˆØ¶ÛŒØ­Ø§Øª)"""
    
    @staticmethod
    def create(task_id: int, section_type: str, file_id: str, file_type: str) -> Optional[int]:
        """
        Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¨Ø®Ø´ Ø®Ø§Øµ
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            section_type: 'results' ÛŒØ§ 'description'
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„ ØªÙ„Ú¯Ø±Ø§Ù…
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ (photo, video, document, voice)
        """
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO TaskSectionFiles (task_id, section_type, file_id, file_type)
                VALUES (?, ?, ?, ?)
            """, (task_id, section_type, file_id, file_type))
            
            file_id_db = cursor.lastrowid
            conn.commit()
            return file_id_db
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ Ø¨Ø®Ø´: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_task(task_id: int, section_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø± (ÛŒØ§ ÛŒÚ© Ø¨Ø®Ø´ Ø®Ø§Øµ)"""
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            
            if section_type:
                cursor.execute("""
                    SELECT * FROM TaskSectionFiles 
                    WHERE task_id = ? AND section_type = ?
                """, (task_id, section_type))
            else:
                cursor.execute("""
                    SELECT * FROM TaskSectionFiles WHERE task_id = ?
                """, (task_id,))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø®Ø´: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def delete_by_task(task_id: int, section_type: Optional[str] = None) -> bool:
        """Ø­Ø°Ù ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø± (ÛŒØ§ ÛŒÚ© Ø¨Ø®Ø´ Ø®Ø§Øµ)"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            
            if section_type:
                cursor.execute("""
                    DELETE FROM TaskSectionFiles 
                    WHERE task_id = ? AND section_type = ?
                """, (task_id, section_type))
            else:
                cursor.execute("""
                    DELETE FROM TaskSectionFiles WHERE task_id = ?
                """, (task_id,))
            
            conn.commit()
            return True
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø®Ø´: {e}")
            return False
        finally:
            conn.close()
    
    @staticmethod
    def delete(file_id: int) -> bool:
        """Ø­Ø°Ù ÛŒÚ© ÙØ§ÛŒÙ„"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM TaskSectionFiles WHERE id = ?", (file_id,))
            conn.commit()
            return cursor.rowcount > 0
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ÙØ§ÛŒÙ„: {e}")
            return False
        finally:
            conn.close()


<a id='database_models_task_work_data_py'></a>
==================================================
# Ø¨Ø®Ø´ 14: database\models\task_work_data.py
==================================================

# database/models/task_work_data.py

from database.connection import create_connection
from datetime import datetime
from typing import Optional, List, Dict, Any


class TaskWorkDataModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ TaskWorkData (Ø¯Ø§Ù†Ø´ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ØŒ Ù†ØªØ§ÛŒØ¬ Ú©Ø§Ø±Ù…Ù†Ø¯)"""
    
    @staticmethod
    def create(task_id: int, user_id: int, data_type: str,
               text_content: Optional[str] = None, file_id: Optional[str] = None,
               file_type: Optional[str] = None) -> Optional[int]:
        """Ø§ÛŒØ¬Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯ Ø¯Ø§Ù†Ø´/Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯/Ù†ØªØ§ÛŒØ¬"""
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            cursor.execute("""
                INSERT INTO TaskWorkData 
                (task_id, user_id, data_type, text_content, file_id, file_type, timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (task_id, user_id, data_type, text_content, file_id, file_type, timestamp))
            
            data_id = cursor.lastrowid
            conn.commit()
            return data_id
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø§Ø¯Ù‡ Ú©Ø§Ø±ÛŒ: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_task(task_id: int, data_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ ÛŒÚ© task"""
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            
            if data_type:
                cursor.execute("""
                    SELECT * FROM TaskWorkData 
                    WHERE task_id = ? AND data_type = ?
                    ORDER BY timestamp ASC
                """, (task_id, data_type))
            else:
                cursor.execute("""
                    SELECT * FROM TaskWorkData 
                    WHERE task_id = ?
                    ORDER BY timestamp ASC
                """, (task_id,))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def get_by_task_and_user(task_id: int, user_id: int, data_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¯Ø± ÛŒÚ© task"""
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            
            if data_type:
                cursor.execute("""
                    SELECT * FROM TaskWorkData 
                    WHERE task_id = ? AND user_id = ? AND data_type = ?
                    ORDER BY timestamp ASC
                """, (task_id, user_id, data_type))
            else:
                cursor.execute("""
                    SELECT * FROM TaskWorkData 
                    WHERE task_id = ? AND user_id = ?
                    ORDER BY timestamp ASC
                """, (task_id, user_id))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def delete_by_task(task_id: int) -> bool:
        """Ø­Ø°Ù ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ ÛŒÚ© task"""
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM TaskWorkData WHERE task_id = ?", (task_id,))
            conn.commit()
            return True
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ: {e}")
            return False
        finally:
            conn.close()


<a id='database_models_user_py'></a>
==================================================
# Ø¨Ø®Ø´ 15: database\models\user.py
==================================================

# database/models/user.py

from database.connection import create_connection
from datetime import datetime
from typing import Optional, List, Dict, Any


class UserModel:
    """Ù…Ø¯Ù„ CRUD Ø¨Ø±Ø§ÛŒ Ø¬Ø¯ÙˆÙ„ Users"""
    
    @staticmethod
    def create(telegram_id: int, first_name: str, last_name: str, 
               phone_number: Optional[str] = None) -> bool:
        """
        Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯
        
        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù… Ú©Ø§Ø±Ø¨Ø±
            first_name: Ù†Ø§Ù…
            last_name: Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ
            phone_number: Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            full_name = f"{first_name} {last_name}".strip()
            
            cursor.execute("""
                INSERT OR IGNORE INTO Users 
                (telegram_id, first_name, last_name, name, phone_number, role, registration_date) 
                VALUES (?, ?, ?, ?, ?, 'pending', ?)
            """, (telegram_id, first_name, last_name, full_name, phone_number, 
                  datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
            
            conn.commit()
            return cursor.rowcount > 0
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±: {e}")
            return False
        finally:
            conn.close()
    
    @staticmethod
    def get_by_telegram_id(telegram_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ telegram_id
        
        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
            
        Returns:
            dict ÛŒØ§ None
        """
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Users WHERE telegram_id = ?", (telegram_id,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_by_id(user_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ id
        
        Args:
            user_id: Ø¢ÛŒØ¯ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
            
        Returns:
            dict ÛŒØ§ None
        """
        conn = create_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Users WHERE id = ?", (user_id,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±: {e}")
            return None
        finally:
            conn.close()
    
    @staticmethod
    def get_all_pending() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯
        
        Returns:
            Ù„ÛŒØ³Øª Ø§Ø² dict Ù‡Ø§
        """
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, telegram_id, name, registration_date, is_employee 
                FROM Users 
                WHERE role = 'pending' OR (role = 'employee' AND is_employee = 0)
                ORDER BY registration_date DESC
            """)
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† pending: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def get_all_employees() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†
        
        Returns:
            Ù„ÛŒØ³Øª Ø§Ø² dict Ù‡Ø§
        """
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, telegram_id, name 
                FROM Users 
                WHERE is_employee = 1 AND role = 'employee'
                ORDER BY name
            """)
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def get_all() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù† (ØºÛŒØ± Ø§Ø² Ø§Ø¯Ù…ÛŒÙ†)
        
        Returns:
            Ù„ÛŒØ³Øª Ø§Ø² dict Ù‡Ø§
        """
        conn = create_connection()
        if not conn:
            return []
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT id, telegram_id, name, role, is_employee, registration_date 
                FROM Users 
                WHERE role != 'admin'
                ORDER BY registration_date DESC
            """)
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: {e}")
            return []
        finally:
            conn.close()
    
    @staticmethod
    def approve_as_employee(telegram_id: int) -> bool:
        """
        ØªØ¨Ø¯ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯
        
        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        conn = create_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE Users 
                SET role = 'employee', is_employee = 1, approved_date = ?
                WHERE telegram_id = ?
            """, (datetime.now().strftime("%Y-%m-%d %H:%M:%S"), telegram_id))
            
            conn.commit()
            return cursor.rowcount > 0
            
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ£ÛŒÛŒØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯: {e}")
            return False
        finally:
            conn.close()
    
    @staticmethod
    def is_admin(telegram_id: int) -> bool:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø¨ÙˆØ¯Ù† Ú©Ø§Ø±Ø¨Ø±
        
        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
            
        Returns:
            bool: Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª ÛŒØ§ Ù†Ù‡
        """
        user = UserModel.get_by_telegram_id(telegram_id)
        return user and user.get('role') == 'admin'
    
    @staticmethod
    def is_employee(telegram_id: int) -> bool:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¨ÙˆØ¯Ù† Ú©Ø§Ø±Ø¨Ø±
        
        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
            
        Returns:
            bool: Ú©Ø§Ø±Ù…Ù†Ø¯ Ø§Ø³Øª ÛŒØ§ Ù†Ù‡
        """
        user = UserModel.get_by_telegram_id(telegram_id)
        return user and user.get('role') == 'employee' and user.get('is_employee') == 1


<a id='database_models___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 16: database\models\__init__.py
==================================================

# database/models/__init__.py

from database.models.user import UserModel
from database.models.task import TaskModel
from database.models.category import CategoryModel
from database.models.admin_review import AdminReviewModel
from database.models.task_work_data import TaskWorkDataModel
from database.models.task_attachment import TaskAttachmentModel
from database.models.task_section_file import TaskSectionFileModel

__all__ = [
    'UserModel',
    'TaskModel',
    'CategoryModel',
    'AdminReviewModel',
    'TaskWorkDataModel',
    'TaskAttachmentModel',
    'TaskSectionFileModel'
]


<a id='handlers_registration_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 17: handlers\registration_handler.py
==================================================

# handlers/registration_handler.py

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import (
    ContextTypes, ConversationHandler, CommandHandler, MessageHandler, filters
)

# âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Services Ø¨Ù‡ Ø¬Ø§ÛŒ database_manager
from services.user_service import UserService

# âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Utils
from utils.constants import GET_FULL_NAME, GET_PHONE
from utils.keyboards import (
    get_main_menu_keyboard, 
    get_employee_main_keyboard, 
    get_phone_request_keyboard
)
from utils.validators import validate_full_name

from config import ADMIN_ID


async def check_and_start_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ø§Ø±Ø¨Ø± Ø§Ø¯Ù…ÛŒÙ†ØŒ Ú©Ø§Ø±Ø¨Ø± Ù‚Ø¯ÛŒÙ…ÛŒ ÛŒØ§ Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ Ø§Ø³Øª"""
    user_id = update.effective_user.id

    # âœ… Ú†Ú© Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø§ UserService
    if UserService.is_admin(user_id):
        await update.message.reply_text(
            "ğŸ‘‹ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ØŒ Ù…Ø¯ÛŒØ± Ø¹Ø²ÛŒØ²!",
            reply_markup=get_main_menu_keyboard()  # âœ… Ø§Ø² utils
        )
        return ConversationHandler.END

    # âœ… Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ UserService
    user = UserService.get_user_info(user_id)

    # Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª
    if user:
        # Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡
        if user.get('is_employee') == 1 and user.get('role') == 'employee':
            await update.message.reply_text(
                f"ğŸ‘‹ Ø³Ù„Ø§Ù… {user['name']} Ø¹Ø²ÛŒØ²!\n\nØ®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.",
                reply_markup=get_employee_main_keyboard()  # âœ… Ø§Ø² utils
            )
            return ConversationHandler.END
        else:
            # Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯
            await update.message.reply_text(
                f"ğŸ‘‹ Ø³Ù„Ø§Ù… {user['name']} Ø¹Ø²ÛŒØ²!\n\n"
                f"â³ Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯ Ù…Ø¯ÛŒØ± Ø§Ø³Øª.\n"
                f"Ù„Ø·ÙØ§Ù‹ ØµØ¨ÙˆØ± Ø¨Ø§Ø´ÛŒØ¯."
            )
            return ConversationHandler.END

    # Ø´Ø±ÙˆØ¹ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯
    await update.message.reply_text(
        "ğŸ‘‹ **Ø³Ù„Ø§Ù…! Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.**\n\n"
        "Ù„Ø·ÙØ§Ù‹ **Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ** Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n\n"
        "Ù…Ø«Ø§Ù„: Ø¹Ù„ÛŒ Ø§Ø­Ù…Ø¯ÛŒ",
        parse_mode='Markdown'
    )
    return GET_FULL_NAME


async def start_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…"""
    await update.message.reply_text(
        "ğŸ‘‹ **Ø³Ù„Ø§Ù…! Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.**\n\n"
        "Ù„Ø·ÙØ§Ù‹ **Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ** Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n\n"
        "Ù…Ø«Ø§Ù„: Ø¹Ù„ÛŒ Ø§Ø­Ù…Ø¯ÛŒ",
        parse_mode='Markdown'
    )
    return GET_FULL_NAME


async def get_full_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù… Ú©Ø§Ù…Ù„"""
    full_name = update.message.text.strip()

    # âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² validator
    is_valid, error_message = validate_full_name(full_name)
    
    if not is_valid:
        await update.message.reply_text(error_message)
        return GET_FULL_NAME

    # Ø¬Ø¯Ø§Ø³Ø§Ø²ÛŒ Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ
    name_parts = full_name.split()
    first_name = name_parts[0]
    last_name = ' '.join(name_parts[1:])

    context.user_data['first_name'] = first_name
    context.user_data['last_name'] = last_name

    # âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² keyboard Ø§Ø² utils
    await update.message.reply_text(
        f"âœ… Ù†Ø§Ù…: **{full_name}**\n\n"
        f"Ø­Ø§Ù„Ø§ Ù„Ø·ÙØ§Ù‹ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØªØ§ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø´Ù…Ø§ Ø«Ø¨Øª Ø´ÙˆØ¯:",
        reply_markup=get_phone_request_keyboard(),  # âœ… Ø§Ø² utils
        parse_mode='Markdown'
    )
    return GET_PHONE


async def get_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ùˆ Ø«Ø¨Øª Ú©Ø§Ø±Ø¨Ø±"""
    contact = update.message.contact

    if not contact:
        await update.message.reply_text(
            "âŒ Ù„Ø·ÙØ§Ù‹ Ø§Ø² Ø¯Ú©Ù…Ù‡ **ğŸ“± Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†** Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.",
            parse_mode='Markdown'
        )
        return GET_PHONE

    first_name = context.user_data.get('first_name')
    last_name = context.user_data.get('last_name')
    phone_number = contact.phone_number
    telegram_id = update.effective_user.id

    # âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² UserService
    success = UserService.register_user(telegram_id, first_name, last_name, phone_number)
    
    if success:
        await update.message.reply_text(
            f"âœ… **Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ù…ÙˆÙÙ‚!**\n\n"
            f"ğŸ‘¤ Ù†Ø§Ù…: {first_name} {last_name}\n"
            f"ğŸ“± Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†: {phone_number}\n\n"
            f"â³ Ù„Ø·ÙØ§Ù‹ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯ ØªØ§ Ù…Ø¯ÛŒØ± Ø´Ù…Ø§ Ø±Ø§ ØªØ£ÛŒÛŒØ¯ Ú©Ù†Ø¯.\n"
            f"Ù¾Ø³ Ø§Ø² ØªØ£ÛŒÛŒØ¯ØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ø§Ù…Ú©Ø§Ù†Ø§Øª Ø¨Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.",
            reply_markup=ReplyKeyboardRemove(),
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…! Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯:\n/start",
            reply_markup=ReplyKeyboardRemove()
        )

    return ConversationHandler.END


async def cancel_registration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…"""
    await update.message.reply_text(
        "âŒ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ù„ØºÙˆ Ø´Ø¯.\n\n"
        "Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯ØŒ /start Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END


# ConversationHandler Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…
registration_conv_handler = ConversationHandler(
    entry_points=[
        CommandHandler("start", check_and_start_registration)
    ],
    states={
        GET_FULL_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_full_name),
            CommandHandler("cancel", cancel_registration)
        ],
        GET_PHONE: [
            MessageHandler(filters.CONTACT, get_phone),
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_phone),
            CommandHandler("cancel", cancel_registration)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_registration)
    ],
    per_message=False,
    per_chat=True,
    per_user=True,
    allow_reentry=True
)


<a id='handlers___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 18: handlers\__init__.py
==================================================

# handlers/__init__.py


<a id='handlers_admin_category_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 19: handlers\admin\category_handler.py
==================================================

# handlers/admin/category_handler.py

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ConversationHandler, ContextTypes, MessageHandler, CallbackQueryHandler, filters, \
    CommandHandler
from database.models.category import CategoryModel

GET_CATEGORY_NAME = 0


async def show_categories_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§"""
    query = update.callback_query
    await query.answer()

    categories = CategoryModel.get_all()

    keyboard = []
    for cat in categories:
        keyboard.append([InlineKeyboardButton(cat['name'], callback_data=f"category_{cat['id']}")])

    keyboard.append([InlineKeyboardButton("â• ØªØ¹Ø±ÛŒÙ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯", callback_data="new_category")])
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("ğŸ“‚ Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§:", reply_markup=reply_markup)


async def start_new_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ØªØ¹Ø±ÛŒÙ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯"""
    query = update.callback_query
    await query.answer()

    await query.edit_message_text(
        "Ù„Ø·ÙØ§ Ø¹Ù†ÙˆØ§Ù† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )
    return GET_CATEGORY_NAME


async def save_new_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯"""
    category_name = update.message.text.strip()

    if not category_name:
        await update.message.reply_text("âŒ Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯!")
        return GET_CATEGORY_NAME

    # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ
    existing = CategoryModel.get_by_name(category_name)
    if existing:
        await update.message.reply_text("âŒ Ø§ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯.")
        return GET_CATEGORY_NAME

    # Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯
    category_id = CategoryModel.create(category_name)

    if category_id:
        await update.message.reply_text(f"âœ… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ '{category_name}' Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯.")
    else:
        await update.message.reply_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ!")

    await show_categories_menu_direct(update, context)
    return ConversationHandler.END


async def show_categories_menu_direct(update, context):
    """Ù†Ù…Ø§ÛŒØ´ Ù…Ø³ØªÙ‚ÛŒÙ… Ù…Ù†ÙˆÛŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§"""
    categories = CategoryModel.get_all()

    keyboard = []
    for cat in categories:
        keyboard.append([InlineKeyboardButton(cat['name'], callback_data=f"category_{cat['id']}")])

    keyboard.append([InlineKeyboardButton("â• ØªØ¹Ø±ÛŒÙ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯", callback_data="new_category")])
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("ğŸ“‚ Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§:", reply_markup=reply_markup)


async def cancel_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ ÙØ±Ø¢ÛŒÙ†Ø¯ ØªØ¹Ø±ÛŒÙ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ"""
    await update.message.reply_text("âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.")
    return ConversationHandler.END


category_conv_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_new_category, pattern='^new_category$')
    ],
    states={
        GET_CATEGORY_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, save_new_category),
            CommandHandler("cancel", cancel_category)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_category)
    ],
    per_message=False,
    per_chat=True,
    per_user=True,
    allow_reentry=True
)

<a id='handlers_admin_completed_tasks_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 20: handlers\admin\completed_tasks_handler.py
==================================================

# handlers/admin/completed_tasks_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, Bot
from telegram.ext import (
    ContextTypes, ConversationHandler, CallbackQueryHandler, CommandHandler, MessageHandler, filters
)
from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService
from utils.constants import GET_FULL_NAME, GET_PHONE
from utils.keyboards import get_main_menu_keyboard, get_employee_main_keyboard
from utils.validators import validate_full_name
import datetime
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, Bot
from telegram.ext import (
    ContextTypes, ConversationHandler, CallbackQueryHandler, CommandHandler, MessageHandler, filters
)
# ÙˆØ¶Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù„Ù…Ù‡
(
    ADMIN_REVIEW_OPINION_TEXT, ADMIN_REVIEW_OPINION_FILE,
    ADMIN_REVIEW_POSITIVE_TEXT, ADMIN_REVIEW_POSITIVE_FILE,
    ADMIN_REVIEW_NEGATIVE_TEXT, ADMIN_REVIEW_NEGATIVE_FILE,
    ADMIN_REVIEW_SUGGESTION_TEXT, ADMIN_REVIEW_SUGGESTION_FILE,
    ADMIN_TASK_SCORE
) = range(50, 59)


async def show_completed_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†"""
    query = update.callback_query
    await query.answer()

    try:
        # Refactored: Use TaskService to fetch tasks needing admin review
        # The result format is assumed to be (task_id, title, employee_name, completion_date)
        completed_tasks = TaskService.get_tasks_for_admin_review()

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡!")
        return

    if not completed_tasks:
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data="show_menu")]]
        await query.edit_message_text(
            "âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡\n\n"
            "ğŸ“ Ù‡ÛŒÚ† Ú©Ø§Ø± ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        return

    keyboard = []
    for task_id, title, employee_name, completion_date in completed_tasks:
        keyboard.append([
            InlineKeyboardButton(f"{title} ({employee_name})", callback_data=f"review_task_{task_id}")
        ])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data="show_menu")])

    await query.edit_message_text(
        "âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡\n\n"
        "Ú©Ø§Ø± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

async def show_task_review_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['review_task_id'] = task_id

    # Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
    try:
        # Refactored: Use TaskService to get task review info (returns dict)
        task_info = TaskService.get_task_review_info(task_id)
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±!")
        return

    if task_info:
        title = task_info.get('title')
        employee_name = task_info.get('employee_name')
        completion_date = task_info.get('completion_date')

        keyboard = [
            [InlineKeyboardButton("ğŸ“‹ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø±", callback_data=f"task_profile_{task_id}")],
            [InlineKeyboardButton("ğŸ“Š Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ù†ÛŒØ±Ùˆ", callback_data=f"employee_outputs_{task_id}")],
            [InlineKeyboardButton("ğŸ’­ Ù†Ø¸Ø± Ø´Ù…Ø§", callback_data=f"admin_opinion_{task_id}")],
            [InlineKeyboardButton("âœ… Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª", callback_data=f"positive_points_{task_id}")],
            [InlineKeyboardButton("âŒ Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ", callback_data=f"negative_points_{task_id}")],
            [InlineKeyboardButton("ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯/Ø§Ù†ØªÙ‚Ø§Ø¯", callback_data=f"admin_suggestion_{task_id}")],
            [InlineKeyboardButton("â­ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ú©Ø§Ø±", callback_data=f"admin_score_{task_id}")],
            [InlineKeyboardButton("ğŸ”š Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø±", callback_data=f"finalize_task_{task_id}")],
            [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="completed_tasks")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            f"Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±: {title}\n"
            f"Ú©Ø§Ø±Ù…Ù†Ø¯: {employee_name}\n"
            f"ØªØ­ÙˆÛŒÙ„: {completion_date}",
            reply_markup=reply_markup
        )


async def show_task_profile_for_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    user_telegram_id = query.from_user.id

    try:
        # Refactored: Use TaskService
        task_info = TaskService.get_task_profile_for_admin(task_id)

        # Refactored: Use FileService
        attachments = FileService.get_task_attachments(task_id)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±!")
        return

    if task_info:
        # Accessing dict fields
        title = task_info.get('title')
        description = task_info.get('description')
        duration = task_info.get('duration')
        results = task_info.get('results')
        importance = task_info.get('importance')
        priority = task_info.get('priority')
        creation_date = task_info.get('creation_date')
        completion_date = task_info.get('completion_date')
        employee_name = task_info.get('employee_name')
        category_name = task_info.get('category_name')

        message_text = (
            f"ğŸ“‹ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø±\n\n"
            f"Ø¹Ù†ÙˆØ§Ù†: {title}\n"
            f"Ú©Ø§Ø±Ù…Ù†Ø¯: {employee_name}\n"
            f"Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {category_name or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"Ù…Ø¯Øª Ø²Ù…Ø§Ù†: {duration or 'Ù†Ø¯Ø§Ø±Ø¯'} Ø¯Ù‚ÛŒÙ‚Ù‡\n"
            f"Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: {results or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"ØªÙˆØ¶ÛŒØ­Ø§Øª: {description or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"Ø§Ù‡Ù…ÛŒØª: {importance or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"Ø§ÙˆÙ„ÙˆÛŒØª: {priority or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯: {creation_date}\n"
            f"ØªØ§Ø±ÛŒØ® ØªØ­ÙˆÛŒÙ„: {completion_date}"
        )
        await query.edit_message_text(message_text)

    if attachments:
        bot = Bot(token=context.bot_data['bot_token'])
        for file_id, file_type in attachments:
            try:
                if file_type == 'photo':
                    await bot.send_photo(chat_id=user_telegram_id, photo=file_id)
                elif file_type == 'video':
                    await bot.send_video(chat_id=user_telegram_id, video=file_id)
                elif file_type == 'voice':
                    await bot.send_voice(chat_id=user_telegram_id, voice=file_id)
                elif file_type == 'document':
                    await bot.send_document(chat_id=user_telegram_id, document=file_id)
            except Exception as e:
                print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"review_task_{task_id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await context.bot.send_message(
        chat_id=user_telegram_id,
        text="Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª:",
        reply_markup=reply_markup
    )


async def show_employee_outputs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ù…Ù„ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ù†ÛŒØ±Ùˆ Ø¨Ø§ ØªÙÚ©ÛŒÚ©"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    user_telegram_id = query.from_user.id

    try:
        # Refactored: Use TaskService
        employee_name = TaskService.get_employee_name_for_task(task_id)
        if not employee_name:
            await query.edit_message_text("âŒ Ú©Ø§Ø±Ù…Ù†Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯!")
            return

        # Refactored: Use WorkService
        work_data = WorkService.get_task_work_data(task_id)

        # Refactored: Use TaskService (TaskScores is assumed to be handled by TaskService)
        self_score = TaskService.get_task_self_score(task_id)

        # Ø¨Ø±Ø±Ø³ÛŒ Ø®Ø§Ù„ÛŒ Ø¨ÙˆØ¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        if not work_data and not self_score:
            await query.edit_message_text(
                f"ğŸ“Š Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±\n"
                f"ğŸ‘¤ Ú©Ø§Ø±Ù…Ù†Ø¯: {employee_name}\n\n"
                f"âš ï¸ Ø§ÛŒÙ† Ú©Ø§Ø±Ù…Ù†Ø¯ Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ† Ø®Ø±ÙˆØ¬ÛŒ ÛŒØ§ Ø§Ù…ØªÛŒØ§Ø²ÛŒ Ø«Ø¨Øª Ù†Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª.",
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"review_task_{task_id}")
                ]])
            )
            return

        # Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
        grouped_data = {}
        for data_type, text_content, file_id, file_type, timestamp in work_data:
            if data_type not in grouped_data:
                grouped_data[data_type] = []
            grouped_data[data_type].append({
                'text': text_content,
                'file_id': file_id,
                'file_type': file_type
            })

        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø§ÙˆÙ„ÛŒÙ‡
        await query.edit_message_text(
            f"ğŸ“Š Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±\n"
            f"ğŸ‘¤ Ú©Ø§Ø±Ù…Ù†Ø¯: {employee_name}\n\n"
            f"Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø¬Ø²Ø¦ÛŒØ§Øª...",
            parse_mode='Markdown'
        )

        # ØªØ¹Ø±ÛŒÙ Ø§Ù†ÙˆØ§Ø¹ Ùˆ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ ÙØ§Ø±Ø³ÛŒ
        data_types = {
            'knowledge': 'ğŸ“š Ø¯Ø§Ù†Ø´ Ø«Ø¨Øª Ø´Ø¯Ù‡',
            'suggestion': 'ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª',
            'results': 'ğŸ“‹ Ù†ØªØ§ÛŒØ¬ Ú©Ø§Ø±'
        }

        # Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø§Ø±Ø³Ø§Ù„
        items_sent = 0

        # Ù†Ù…Ø§ÛŒØ´ Ù‡Ø± Ø¯Ø³ØªÙ‡
        for data_type, persian_name in data_types.items():
            if data_type in grouped_data:
                items_sent += 1

                # Ø§Ø±Ø³Ø§Ù„ Ù‡Ø¯Ø±
                await context.bot.send_message(
                    chat_id=user_telegram_id,
                    text=f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n{persian_name}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
                    parse_mode='Markdown'
                )

                # Ø§Ø±Ø³Ø§Ù„ Ù…Ø­ØªÙˆØ§
                text_items = []
                file_items = []

                for item in grouped_data[data_type]:
                    if item['text']:
                        text_items.append(item['text'])
                    if item['file_id']:
                        file_items.append(item)

                # Ø§Ø±Ø³Ø§Ù„ Ù…ØªÙ†â€ŒÙ‡Ø§
                if text_items:
                    combined_text = "\n\n".join([f"ğŸ“ {text}" for text in text_items])
                    # ØªÙ‚Ø³ÛŒÙ… Ø¨Ù‡ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ú©ÙˆÚ†Ú©ØªØ± Ø§Ú¯Ø± Ø®ÛŒÙ„ÛŒ Ø·ÙˆÙ„Ø§Ù†ÛŒ Ø¨ÙˆØ¯
                    if len(combined_text) > 4000:
                        for i in range(0, len(combined_text), 4000):
                            await context.bot.send_message(
                                chat_id=user_telegram_id,
                                text=combined_text[i:i + 4000],
                                parse_mode='Markdown'
                            )
                    else:
                        await context.bot.send_message(
                            chat_id=user_telegram_id,
                            text=combined_text,
                            parse_mode='Markdown'
                        )

                # Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
                for item in file_items:
                    try:
                        if item['file_type'] == 'photo':
                            await context.bot.send_photo(chat_id=user_telegram_id, photo=item['file_id'])
                        elif item['file_type'] == 'video':
                            await context.bot.send_video(chat_id=user_telegram_id, video=item['file_id'])
                        elif item['file_type'] == 'voice':
                            await context.bot.send_voice(chat_id=user_telegram_id, voice=item['file_id'])
                        elif item['file_type'] == 'document':
                            await context.bot.send_document(chat_id=user_telegram_id, document=item['file_id'])
                    except Exception as e:
                        print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")
                        await context.bot.send_message(
                            chat_id=user_telegram_id,
                            text=f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {str(e)}"
                        )

        # Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯
        if self_score:
            items_sent += 1
            await context.bot.send_message(
                chat_id=user_telegram_id,
                text=f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ­ Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯: {self_score}/10",
                parse_mode='Markdown'
            )

        # Ø§Ú¯Ù‡ Ù‡ÛŒÚ†ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù†Ø´Ø¯
        if items_sent == 0:
            await context.bot.send_message(
                chat_id=user_telegram_id,
                text="âš ï¸ Ù‡ÛŒÚ† Ø®Ø±ÙˆØ¬ÛŒ Ù‚Ø§Ø¨Ù„ Ù†Ù…Ø§ÛŒØ´ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.",
                parse_mode='Markdown'
            )

        # Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"review_task_{task_id}")]]
        await context.bot.send_message(
            chat_id=user_telegram_id,
            text="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± show_employee_outputs: {e}")
        import traceback
        traceback.print_exc()

        try:
            await query.edit_message_text(
                f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§\n\n"
                f"Ø®Ø·Ø§: {str(e)}\n\n"
                f"Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯.",
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"review_task_{task_id}")
                ]])
            )
        except:
            # Ø§Ú¯Ù‡ edit Ú©Ø§Ø± Ù†Ú©Ø±Ø¯ØŒ Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯ Ø¨ÙØ±Ø³Øª
            await context.bot.send_message(
                chat_id=user_telegram_id,
                text=f"âŒ Ø®Ø·Ø§: {str(e)}",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"review_task_{task_id}")
                ]])
            )


# ØªÙˆØ§Ø¨Ø¹ Ø´Ø±ÙˆØ¹ Ù…Ú©Ø§Ù„Ù…Ø§Øª Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†
async def start_admin_opinion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ Ø«Ø¨Øª Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['admin_review_task_id'] = task_id
    context.user_data['admin_review_type'] = 'opinion'
    context.user_data['admin_review_messages'] = []

    await query.edit_message_text(
        "ğŸ’­ Ø«Ø¨Øª Ù†Ø¸Ø± Ø´Ù…Ø§\n\n"
        "Ù…Ø±Ø­Ù„Ù‡ 1: Ø§Ø±Ø³Ø§Ù„ Ù…ØªÙ†\n"
        "Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø§ÛŒÙ† Ú©Ø§Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )

    return ADMIN_REVIEW_OPINION_TEXT


async def start_positive_points(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ Ø«Ø¨Øª Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['admin_review_task_id'] = task_id
    context.user_data['admin_review_type'] = 'positive'
    context.user_data['admin_review_messages'] = []

    await query.edit_message_text(
        "âœ… Ø«Ø¨Øª Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª\n\n"
        "Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª Ø§Ù†Ø¬Ø§Ù… Ú©Ø§Ø± Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯:\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )

    return ADMIN_REVIEW_POSITIVE_TEXT


async def start_negative_points(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ Ø«Ø¨Øª Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['admin_review_task_id'] = task_id
    context.user_data['admin_review_type'] = 'negative'
    context.user_data['admin_review_messages'] = []

    await query.edit_message_text(
        "âŒ Ø«Ø¨Øª Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ\n\n"
        "Ù†Ù‚Ø§Ø· Ø¶Ø¹Ù Ùˆ Ù…Ù†ÙÛŒ Ø§Ù†Ø¬Ø§Ù… Ú©Ø§Ø± Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯:\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )

    return ADMIN_REVIEW_NEGATIVE_TEXT


async def start_admin_suggestion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['admin_review_task_id'] = task_id
    context.user_data['admin_review_type'] = 'suggestion'
    context.user_data['admin_review_messages'] = []

    await query.edit_message_text(
        "ğŸ’¡ **Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ø¯ÛŒØ±**\n\n"
        "Ù…Ø±Ø­Ù„Ù‡ Û±: **Ø§Ø±Ø³Ø§Ù„ Ù…ØªÙ†**\n"
        "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
        "**Ø¯Ø³ØªÙˆØ±Ø§Øª:**\n"
        "â€¢ `/end` - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ `/send_file` - Ù¾Ø±Ø´ Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n"
        "â€¢ `/cancel` - Ù„ØºÙˆ",
        parse_mode='Markdown'
    )
    # Ø¨Ø§ ØªÙˆØ¬Ù‡ Ø¨Ù‡ Ø§ÛŒÙ†Ú©Ù‡ Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø¯Ø± ConversationHandler Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŒ
    # Ø¨Ù‡ Ø§Ø­ØªÙ…Ø§Ù„ Ø²ÛŒØ§Ø¯ Ø¨Ø§ÛŒØ¯ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø¹Ø¯ÛŒ Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯.
    # review_type = context.user_data['admin_review_type']
    # return globals()[f"ADMIN_REVIEW_{review_type.upper()}_TEXT"]

async def handle_admin_review_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ù…ØªÙ†â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    text = update.message.text
    context.user_data['admin_review_messages'].append({
        'type': 'text',
        'text': text
    })
    await update.message.reply_text("Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ§Ù† /end ÛŒØ§ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„ /send_file")
    review_type = context.user_data['admin_review_type']
    return globals()[f"ADMIN_REVIEW_{review_type.upper()}_TEXT"]

async def skip_admin_review_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ ÙØ§ÛŒÙ„"""
    review_type = context.user_data['admin_review_type']
    await update.message.reply_text(
        "Ù…Ø±Ø­Ù„Ù‡ 2: Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n\n"
        "ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù†\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return globals()[f"ADMIN_REVIEW_{review_type.upper()}_FILE"]

async def handle_admin_review_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    file_info = None
    if update.message.photo:
        file_info = (update.message.photo[-1].file_id, 'photo')
    elif update.message.video:
        file_info = (update.message.video.file_id, 'video')
    elif update.message.voice:
        file_info = (update.message.voice.file_id, 'voice')
    elif update.message.document:
        file_info = (update.message.document.file_id, 'document')

    if file_info:
        context.user_data['admin_review_messages'].append({
            'type': 'file',
            'file_id': file_info[0],
            'file_type': file_info[1]
        })
        await update.message.reply_text("ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ§Ù† /end")

    review_type = context.user_data['admin_review_type']
    return globals()[f"ADMIN_REVIEW_{review_type.upper()}_FILE"]


async def end_admin_review(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†"""
    task_id = context.user_data['admin_review_task_id']
    review_type = context.user_data['admin_review_type']
    messages = context.user_data.get('admin_review_messages', [])
    admin_telegram_id = update.effective_user.id

    if not messages:
        await update.message.reply_text("âš ï¸ Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡!")
        return ConversationHandler.END

    try:
        # Refactored: Use UserService to get user ID (Rule 4: SELECT * FROM Users -> UserService.get_user_info())
        admin_user = UserService.get_user_info(admin_telegram_id)
        admin_db_id = admin_user.get('id') if admin_user else None

        if not admin_db_id:
            await update.message.reply_text("âŒ Ø®Ø·Ø§: Ø§Ø¯Ù…ÛŒÙ† Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
            return ConversationHandler.END

        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Refactored: Use ReviewService (Rule 4: INSERT/UPDATE Users -> UserService Ù…Ù†Ø§Ø³Ø¨)
        for message in messages:
            if message['type'] == 'text':
                ReviewService.add_admin_review(
                    task_id=task_id,
                    admin_id=admin_db_id,
                    review_type=review_type,
                    text_content=message['text'],
                    timestamp=timestamp
                )
            elif message['type'] == 'file':
                ReviewService.add_admin_review(
                    task_id=task_id,
                    admin_id=admin_db_id,
                    review_type=review_type,
                    file_id=message['file_id'],
                    file_type=message['file_type'],
                    timestamp=timestamp
                )

        await update.message.reply_text(f"âœ… Ù†Ø¸Ø± '{review_type}' Ø«Ø¨Øª Ø´Ø¯.")
        await return_to_review_panel(update, context, task_id)
        return ConversationHandler.END

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†: {e}")
        await update.message.reply_text(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ù†Ø¸Ø±: {str(e)}")
        return ConversationHandler.END


async def handle_admin_score(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø² Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±"""
    admin_telegram_id = update.effective_user.id
    task_id = context.user_data['admin_review_task_id']

    try:
        score = int(update.message.text)
        if not 0 <= score <= 100:
            raise ValueError

        # Refactored: Use UserService (Rule 4)
        admin_user = UserService.get_user_info(admin_telegram_id)
        admin_db_id = admin_user.get('id') if admin_user else None

        if not admin_db_id:
            await update.message.reply_text("âŒ Ø®Ø·Ø§: Ø§Ø¯Ù…ÛŒÙ† Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
            return ConversationHandler.END

        # Refactored: Use ReviewService (Rule 4)
        ReviewService.delete_admin_score(task_id)
        ReviewService.add_admin_score(
            task_id=task_id,
            admin_id=admin_db_id,
            score=score
        )

        await update.message.reply_text("Ø§Ù…ØªÛŒØ§Ø² Ø«Ø¨Øª Ø´Ø¯.")
        await return_to_review_panel(update, context, task_id)
        return ConversationHandler.END

    except ValueError:
        await update.message.reply_text("Ù„Ø·ÙØ§ Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† 0 ØªØ§ 100 ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return ADMIN_TASK_SCORE
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø²: {e}")
        await update.message.reply_text(f"âŒ Ø®Ø·Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¯Ø± Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø²: {str(e)}")
        return ConversationHandler.END


async def return_to_review_panel(update, context, task_id):
    """Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù¾Ù†Ù„ Ø¨Ø±Ø±Ø³ÛŒ"""
    try:
        # Refactored: Use TaskService
        task_info = TaskService.get_task_review_info(task_id)
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±: {e}")
        return

    if task_info:
        title = task_info.get('title')
        employee_name = task_info.get('employee_name')
        completion_date = task_info.get('completion_date')

        keyboard = [
            [InlineKeyboardButton("ğŸ“‹ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø±", callback_data=f"task_profile_{task_id}")],
            [InlineKeyboardButton("ğŸ“Š Ø®Ø±ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ù†ÛŒØ±Ùˆ", callback_data=f"employee_outputs_{task_id}")],
            [InlineKeyboardButton("ğŸ’­ Ù†Ø¸Ø± Ø´Ù…Ø§", callback_data=f"admin_opinion_{task_id}")],
            [InlineKeyboardButton("âœ… Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª", callback_data=f"positive_points_{task_id}")],
            [InlineKeyboardButton("âŒ Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ", callback_data=f"negative_points_{task_id}")],
            [InlineKeyboardButton("ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯/Ø§Ù†ØªÙ‚Ø§Ø¯", callback_data=f"admin_suggestion_{task_id}")],
            [InlineKeyboardButton("â­ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ú©Ø§Ø±", callback_data=f"admin_score_{task_id}")],
            [InlineKeyboardButton("ğŸ”š Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø±", callback_data=f"finalize_task_{task_id}")],
            [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="completed_tasks")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(
            chat_id=update.effective_user.id,
            text=f"Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±: {title}\nÚ©Ø§Ø±Ù…Ù†Ø¯: {employee_name}\nØªØ­ÙˆÛŒÙ„: {completion_date}",
            reply_markup=reply_markup
        )

async def finalize_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø± Ùˆ Ø¢Ø±Ø´ÛŒÙˆ - Ø¨Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…ØªÛŒØ§Ø²"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])

    try:
        # Refactored: Use ReviewService
        score_count = ReviewService.get_admin_score_count(task_id)

        if score_count == 0:
            await query.answer("âš ï¸ Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ Ú©Ø§Ø± Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø¯Ù‡ÛŒØ¯.", show_alert=True)
            return

        # Refactored: Use TaskService for update (Rule 4: INSERT/UPDATE Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
        TaskService.finalize_task(task_id)

        # Refactored: Use TaskService for status check
        updated_status = TaskService.get_task_status(task_id)

        if updated_status == 'archived':
            await query.edit_message_text("âœ… Ú©Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯.")
            import asyncio
            await asyncio.sleep(1)
            await show_completed_tasks_after_finalize(update, context)
        else:
            await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±.")

    except Exception as e:
        print(f"[DEBUG] Ø®Ø·Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ: {e}")
        await query.edit_message_text(f"Ø®Ø·Ø§ Ø±Ø® Ø¯Ø§Ø¯: {str(e)}")

async def show_completed_tasks_after_finalize(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ Ø¨Ø¹Ø¯ Ø§Ø² Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø±"""
    try:
        # Refactored: Use TaskService (Rule 4: SELECT * FROM Tasks -> TaskService.get_completed_tasks())
        completed_tasks = TaskService.get_completed_tasks()

        keyboard = []
        if completed_tasks:
            for task_id, title, employee_name, completion_date in completed_tasks:
                keyboard.append([
                    InlineKeyboardButton(f"{title} ({employee_name})", callback_data=f"review_task_{task_id}")
                ])
            message_text = f"ğŸ“‹ Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ ({len(completed_tasks)} Ú©Ø§Ø±):"
        else:
            message_text = "ğŸ“­ Ù‡ÛŒÚ† Ú©Ø§Ø± ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯."

        keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main_menu")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(
            chat_id=update.effective_user.id,
            text=message_text,
            reply_markup=reply_markup
        )

    except Exception as e:
        print(f"[DEBUG] Ø®Ø·Ø§ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª: {e}")
        await context.bot.send_message(
            chat_id=update.effective_user.id,
            text="âŒ Ø®Ø·Ø§ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡."
        )


async def show_archived_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØªÙ‡ (Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡)"""
    query = update.callback_query
    await query.answer()

    try:
        # Refactored: Use TaskService
        archived_tasks = TaskService.get_archived_tasks()
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØªÙ‡!")
        return

    if not archived_tasks:
        await query.edit_message_text("Ù‡ÛŒÚ† Ú©Ø§Ø± Ø®Ø§ØªÙ…Ù‡â€ŒÛŒØ§ÙØªÙ‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.")
        return

    keyboard = []
    for task_id, title, employee_name, completion_date in archived_tasks:
        keyboard.append([
            InlineKeyboardButton(f"{title} ({employee_name})", callback_data=f"view_archived_{task_id}")
        ])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        f"Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡â€ŒÛŒØ§ÙØªÙ‡ ({len(archived_tasks)} Ú©Ø§Ø±):",
        reply_markup=reply_markup
    )


async def view_archived_task_for_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    user_telegram_id = query.from_user.id

    try:
        # Refactored: Use TaskService
        task_info = TaskService.get_task_review_info(task_id)

        # Refactored: Use ReviewService
        reviews = ReviewService.get_admin_reviews(task_id)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡!")
        return

    if task_info:
        title = task_info.get('title')
        employee_name = task_info.get('employee_name')
        completion_date = task_info.get('completion_date')

        bot = Bot(token=context.bot_data['bot_token'])

        await bot.send_message(
            chat_id=user_telegram_id,
            text=f"ğŸ“‹ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡: {title}\n"
                 f"Ú©Ø§Ø±Ù…Ù†Ø¯: {employee_name}\n"
                 f"ØªØ­ÙˆÛŒÙ„: {completion_date}",
            parse_mode='Markdown'
        )

        await bot.send_message(
            chat_id=user_telegram_id,
            text=f"ğŸ“‹ Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø± {employee_name}:",
            parse_mode='Markdown'
        )

        # Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ø¸Ø±Ø§Øª
        review_types = {
            'opinion': 'ğŸ’­ Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†',
            'positive': 'âœ… Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª',
            'negative': 'âŒ Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ',
            'suggestion': 'ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯/Ø§Ù†ØªÙ‚Ø§Ø¯',
            'score': 'â­ Ø§Ù…ØªÛŒØ§Ø² Ø§Ø¯Ù…ÛŒÙ†'
        }

        for review_type, persian_name in review_types.items():
            type_reviews = [r for r in reviews if r[0] == review_type]
            if type_reviews:
                await bot.send_message(
                    chat_id=user_telegram_id,
                    text=f"{persian_name}:",
                    parse_mode='Markdown'
                )
                for _, text_content, file_id, file_type, admin_score, timestamp in type_reviews:
                    if review_type == 'score':
                        await bot.send_message(
                            chat_id=user_telegram_id,
                            text=f"Ø§Ù…ØªÛŒØ§Ø²: {admin_score}/100"
                        )
                    elif text_content:
                        await bot.send_message(chat_id=user_telegram_id, text=text_content)
                    elif file_id:
                        try:
                            if file_type == 'photo':
                                await bot.send_photo(chat_id=user_telegram_id, photo=file_id)
                            elif file_type == 'video':
                                await bot.send_video(chat_id=user_telegram_id, video=file_id)
                            elif file_type == 'voice':
                                await bot.send_voice(chat_id=user_telegram_id, voice=file_id)
                            elif file_type == 'document':
                                await bot.send_document(chat_id=user_telegram_id, document=file_id)
                        except Exception as e:
                            print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")

        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"view_archived_{task_id}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await bot.send_message(
            chat_id=user_telegram_id,
            text="Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª:",
            reply_markup=reply_markup
        )


async def confirm_finalize_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ£ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒ Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])

    if TaskService.finalize_task(task_id):
        await query.edit_message_text("âœ… Ú©Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ø¢Ø±Ø´ÛŒÙˆ Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯.")
    else:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø±!")


async def show_admin_review_for_archived(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[3])

    reviews = ReviewService.get_all_reviews(task_id)

    text = "ğŸ“Š Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†:\n\n"

    if reviews['opinion']:
        text += "ğŸ’­ Ù†Ø¸Ø±: " + str(len(reviews['opinion'])) + "\n"
    if reviews['positive']:
        text += "âœ… Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª: " + str(len(reviews['positive'])) + "\n"
    if reviews['negative']:
        text += "âŒ Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ: " + str(len(reviews['negative'])) + "\n"
    if reviews['suggestion']:
        text += "ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª: " + str(len(reviews['suggestion'])) + "\n"

    score = ReviewService.get_latest_score(task_id)
    if score:
        text += f"â­ Ø§Ù…ØªÛŒØ§Ø²: {score}/10\n"

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="archived_tasks")]]

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))


async def show_archived_tasks_for_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    archived_tasks = TaskService.get_archived_tasks()

    if not archived_tasks:
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")]]
        await query.edit_message_text(
            "ğŸ—„ Ù‡ÛŒÚ† Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return

    keyboard = []
    for task in archived_tasks:
        keyboard.append([
            InlineKeyboardButton(
                f"{task['title']} ({task['employee_name']})",
                callback_data=f"view_archived_{task['id']}"
            )
        ])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])

    await query.edit_message_text(
        "ğŸ—„ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


completed_tasks_conv_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_admin_opinion, pattern='^admin_opinion_'),
        CallbackQueryHandler(start_positive_points, pattern='^positive_points_'),
        CallbackQueryHandler(start_negative_points, pattern='^negative_points_'),
        CallbackQueryHandler(start_admin_suggestion, pattern='^admin_suggestion_'),
        CallbackQueryHandler(handle_admin_score, pattern='^admin_score_') # ğŸ‘ˆ ØªØºÛŒÛŒØ± Ø¯Ø± Ø§ÛŒÙ† Ø®Ø·
    ],
    states={
        ADMIN_REVIEW_OPINION_TEXT: [...],
        # Ø¨Ù‚ÛŒÙ‡ states
    },
    fallbacks=[...],
    per_message=False,
    per_chat=True,
    per_user=True,
    allow_reentry=True
)

<a id='handlers_admin_daily_report_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 21: handlers\admin\daily_report_handler.py
==================================================

# handlers/admin/daily_report_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService
from datetime import datetime, timedelta


async def show_daily_report_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ù†ÙˆÛŒ Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ - Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ù‡Ø§ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ÛŒ Ø§Ù…Ø±ÙˆØ²"""
    query = update.callback_query
    await query.answer()

    # Rule 3: get_all_employees() -> UserService.get_all_employees() (No change)
    employees = UserService.get_all_employees()

    if not employees:
        await query.edit_message_text(
            "âŒ Ù‡ÛŒÚ† Ú©Ø§Ø±Ù…Ù†Ø¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data="back_to_main_menu")
            ]])
        )
        return

    keyboard = []

    # ØªØ§Ø±ÛŒØ® Ø§Ù…Ø±ÙˆØ²
    today = datetime.now().strftime("%Y-%m-%d")

    try:
        # Note: employees is likely a list of tuples (emp_id, telegram_id, name)
        for emp_id, telegram_id, name in employees:
            try:
                # Refactored: Use TaskService (Rule 4: SELECT COUNT(*) FROM Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
                daily_completed = TaskService.count_daily_completed_tasks(emp_id, today)

                button_text = f"ğŸ‘¤ {name} ({daily_completed} Ú©Ø§Ø±)"
                keyboard.append([
                    InlineKeyboardButton(button_text, callback_data=f"daily_report_{telegram_id}")
                ])

            except Exception as e:
                print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´ {name}: {e}")
                continue

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ÛŒ Ú©Ù„ÛŒ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´: {e}")

    # Ø¯Ú©Ù…Ù‡ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ
    keyboard.append([
        InlineKeyboardButton("ğŸ”„ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ", callback_data="current_tasks")
    ])
    keyboard.append([
        InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data="back_to_main_menu")
    ])

    await query.edit_message_text(
        f"ğŸ“Š **Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡**\n"
        f"ğŸ“… {datetime.now().strftime('%Y/%m/%d')}\n\n"
        f"Ú©Ø§Ø±Ù…Ù†Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def show_employee_daily_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ø±ÛŒ Ø±ÙˆØ²Ø§Ù†Ù‡ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¨Ù‡ ØªÙÚ©ÛŒÚ© Ø³Ø§Ø¹Ø§Øª"""
    query = update.callback_query
    await query.answer()

    telegram_id = int(query.data.split('_')[2])
    today = datetime.now().strftime("%Y-%m-%d")

    try:
        # Refactored: Use UserService (Rule 4: SELECT * FROM Users -> UserService.get_user_info())
        employee_data = UserService.get_user_info(telegram_id)

        if not employee_data:
            await query.edit_message_text("âŒ Ú©Ø§Ø±Ù…Ù†Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯!")
            return

        # Refactored: Use dict access (Rule 5: user tuple -> user dict)
        employee_name = employee_data.get('name')
        user_id = employee_data.get('id')

        # Refactored: Use WorkService (Rule 4)
        activities = WorkService.get_user_daily_activities(user_id, today)

        # Refactored: Use TaskService (Rule 4: SELECT COUNT(*) FROM Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
        completed_count = TaskService.count_daily_completed_tasks(user_id, today)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´!")
        return

    if not activities:
        text = (
            f"ğŸ“Š **Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ {employee_name}**\n"
            f"ğŸ“… {datetime.now().strftime('%Y/%m/%d')}\n\n"
            f"âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡: {completed_count}\n\n"
            f"â„¹ï¸ Ù‡ÛŒÚ† ÙØ¹Ø§Ù„ÛŒØªÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
        )
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="daily_report")]]
        await query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        return

    # Ø³Ø§Ø®Øª Ù…ØªÙ† Ú¯Ø²Ø§Ø±Ø´
    text = (
        f"ğŸ“Š **Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ {employee_name}**\n"
        f"ğŸ“… {datetime.now().strftime('%Y/%m/%d')}\n"
        f"âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡: {completed_count}\n\n"
        f"â± **Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ø§Ù†ÛŒ Ú©Ø§Ø±:**\n"
        f"{'â”€' * 35}\n"
    )
    total_minutes = 0
    for start_time, end_time, task_title, task_duration in activities:
        try:
            # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ datetime
            start_dt = datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S")
            if end_time:
                end_dt = datetime.strptime(end_time, "%Y-%m-%d %H:%M:%S")
                duration = end_dt - start_dt
                minutes = int(duration.total_seconds() / 60)
                total_minutes += minutes
                # âœ… Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ù…Ø§Ù† Ú©Ø§Ø± ØªÙ…Ø§Ù… Ø´Ø¯Ù‡
                text += (
                    f"âœ… {task_title}\n"
                    f"ğŸ• Ø´Ø±ÙˆØ¹: {start_dt.strftime('%H:%M')} | Ù¾Ø§ÛŒØ§Ù†: {end_dt.strftime('%H:%M')}\n"
                    f"â± Ù…Ø¯Øª: {minutes} Ø¯Ù‚ÛŒÙ‚Ù‡\n"
                    f"{'â”€' * 35}\n"
                )
            else:
                # ğŸ”„ Ú©Ø§Ø± Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…
                now = datetime.now()
                elapsed = now - start_dt
                elapsed_minutes = int(elapsed.total_seconds() / 60)
                elapsed_hours = elapsed_minutes // 60
                elapsed_mins = elapsed_minutes % 60
                total_minutes += elapsed_minutes  # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ú©Ù„ Ø²Ù…Ø§Ù† Ø§Ù…Ø±ÙˆØ²
                text += (
                    f"ğŸ”„ {task_title} (Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…)\n"
                    f"ğŸ• Ø´Ø±ÙˆØ¹: {start_dt.strftime('%H:%M')}\n"
                    f"â± Ù…Ø¯Øª ØªØ§ Ú©Ù†ÙˆÙ†: {elapsed_hours}:{elapsed_mins:02d} ({elapsed_minutes} Ø¯Ù‚ÛŒÙ‚Ù‡)\n"
                    f"{'â”€' * 35}\n"
                )
        except Exception as e:
            print(f"Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ù…Ø§Ù†: {e}")
            text += f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ù…Ø§Ù† Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø± {task_title}\n"

    # Ø¬Ù…Ø¹ Ø¨Ù†Ø¯ÛŒ
    total_hours = total_minutes // 60
    total_mins = total_minutes % 60
    text += f"\n**Ø¬Ù…Ø¹ Ú©Ù„ Ø²Ù…Ø§Ù† Ú©Ø§Ø±: {total_hours}:{total_mins:02d} ({total_minutes} Ø¯Ù‚ÛŒÙ‚Ù‡)**"

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="daily_report")]]
    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def show_current_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù… Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø±"""
    query = update.callback_query
    await query.answer()

    try:
        # Refactored: Use WorkService (Rule 4)
        current_tasks = WorkService.get_current_in_progress_tasks()

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª!")
        return

    if not current_tasks:
        text = (
            "ğŸ”„ **Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ**\n\n"
            "â„¹ï¸ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ù‡ÛŒÚ† Ú©Ø§Ø±ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù… Ù†ÛŒØ³Øª."
        )
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="daily_report")]]
        await query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        return

    text = (
        f"ğŸ”„ **Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ**\n"
        f"ğŸ“… {datetime.now().strftime('%Y/%m/%d - %H:%M')}\n\n"
    )

    for employee_name, task_title, start_time, task_duration in current_tasks:
        try:
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ú©Ø§Ø±
            start_dt = datetime.strptime(start_time, "%Y-%m-%d %H:%M:%S")
            now = datetime.now()
            elapsed = now - start_dt
            elapsed_minutes = int(elapsed.total_seconds() / 60)

            elapsed_hours = elapsed_minutes // 60
            elapsed_mins = elapsed_minutes % 60

            # Ø²Ù…Ø§Ù† ØªØ¹ÛŒÛŒÙ† Ø´Ø¯Ù‡
            duration_str = task_duration if task_duration else "ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡"

            text += (
                f"ğŸ‘¤ **{employee_name}**\n"
                f"ğŸ“‹ {task_title}\n"
                f"ğŸ• Ø´Ø±ÙˆØ¹: {start_dt.strftime('%H:%M')}\n"
                f"â± Ù…Ø¯Øª ØªØ§ Ú©Ù†ÙˆÙ†: {elapsed_hours}:{elapsed_mins:02d} ({elapsed_minutes} Ø¯Ù‚ÛŒÙ‚Ù‡)\n"
                f"ğŸ“… Ø²Ù…Ø§Ù† Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø´Ø¯Ù‡: {duration_str}\n"
                f"{'â”€' * 35}\n\n"
            )
        except Exception as e:
            print(f"Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ø±: {e}")
            continue

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="daily_report")]]
    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

<a id='handlers_admin_define_task_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 22: handlers\admin\define_task_handler.py
==================================================

# handlers/admin/define_task_handler.py

import datetime
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardRemove
from telegram.ext import (
    ConversationHandler, ContextTypes, MessageHandler, CallbackQueryHandler, filters, CommandHandler
)

from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService



# --- ÙˆØ¶Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù„Ù…Ù‡ ---
(
    GET_TITLE, GET_DURATION,
    GET_RESULTS_TEXT, GET_RESULTS_FILE,
    GET_DESCRIPTION_TEXT, GET_DESCRIPTION_FILE,
    GET_IMPORTANCE, GET_PRIORITY, SELECT_ASSIGNEE, SELECT_CATEGORY
) = range(10)

# Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆÙ‚Øª Ù‡Ø± Ú©Ø§Ø±
tasks_in_progress = {}


# --- ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ---
def get_main_menu_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯."""
    keyboard = [
        [
            InlineKeyboardButton("â• ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±", callback_data="define_task"),
            InlineKeyboardButton("âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±", callback_data="edit_task")
        ],
        [
            InlineKeyboardButton("ğŸ“‹ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§", callback_data="manage_tasks"),
            InlineKeyboardButton("ğŸ“‚ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§", callback_data="categories")
        ],
        [
            InlineKeyboardButton("âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡", callback_data="completed_tasks"),
            InlineKeyboardButton("ğŸ—„ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡â€ŒÛŒØ§ÙØªÙ‡", callback_data="archived_tasks")
        ],
        [
            InlineKeyboardButton("ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", callback_data="user_management"),
            InlineKeyboardButton("ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡", callback_data="daily_report")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


# --- Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ø¨Ø§Øª (Ù‚Ø§Ø¨Ù„ÛŒØª ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±) ---
async def start_task_creation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù‡Ù†Ø¯Ù„Ø± Ø´Ø±ÙˆØ¹ Ù…Ú©Ø§Ù„Ù…Ù‡ ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±."""
    query = update.callback_query
    await query.answer()

    # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
    context.user_data.clear()
    if query.from_user.id in tasks_in_progress:
        del tasks_in_progress[query.from_user.id]

    tasks_in_progress[query.from_user.id] = {}

    await query.edit_message_text(
        "ğŸ“ **ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø± Ø¬Ø¯ÛŒØ¯**\n\n"
        "Ù„Ø·ÙØ§Ù‹ Ø¹Ù†ÙˆØ§Ù† Ú©Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.",
        parse_mode='Markdown'
    )
    return GET_TITLE


async def get_title(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø¹Ù†ÙˆØ§Ù† Ú©Ø§Ø±."""
    tasks_in_progress[update.effective_user.id]["title"] = update.message.text
    await update.message.reply_text(
        "âœ… Ø¹Ù†ÙˆØ§Ù† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "Ø­Ø§Ù„Ø§ Ù…Ø¯Øª Ø²Ù…Ø§Ù† ØªØ¹ÛŒÛŒÙ† Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ú©Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø«Ø§Ù„: Û² Ø³Ø§Ø¹Øª).\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )
    return GET_DURATION


async def get_duration(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ù…Ø¯Øª Ø²Ù…Ø§Ù†."""
    tasks_in_progress[update.effective_user.id]["duration"] = update.message.text
    tasks_in_progress[update.effective_user.id]["results_messages"] = []

    await update.message.reply_text(
        "âœ… Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "ğŸ“‹ Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±\n\n"
        "Ù…Ø±Ø­Ù„Ù‡ 1: Ø§Ø±Ø³Ø§Ù„ Ù…ØªÙ†\n"
        "Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± Ø±Ø§ ØªÙˆØ¶ÛŒØ­ Ø¯Ù‡ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return GET_RESULTS_TEXT


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def handle_results_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ù…ØªÙ† Ù†ØªØ§ÛŒØ¬"""
    message_text = update.message.text
    tasks_in_progress[update.effective_user.id]["results_messages"].append({
        'type': 'text',
        'content': message_text
    })

    await update.message.reply_text(
        "âœ… Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ù…ØªÙ† Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return GET_RESULTS_TEXT


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def skip_results_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ ÙØ§ÛŒÙ„ Ù†ØªØ§ÛŒØ¬"""
    await update.message.reply_text(
        "Ù…Ø±Ø­Ù„Ù‡ 2: Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n\n"
        "ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù†\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return GET_RESULTS_FILE


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def handle_results_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„ Ù†ØªØ§ÛŒØ¬"""
    file_info = None
    if update.message.photo:
        file_info = (update.message.photo[-1].file_id, 'photo')
    elif update.message.video:
        file_info = (update.message.video.file_id, 'video')
    elif update.message.voice:
        file_info = (update.message.voice.file_id, 'voice')
    elif update.message.document:
        file_info = (update.message.document.file_id, 'document')

    if file_info:
        tasks_in_progress[update.effective_user.id]["results_messages"].append({
            'type': 'file',
            'file_id': file_info[0],
            'file_type': file_info[1]
        })
        await update.message.reply_text("âœ… ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\nâ€¢ /end - Ù¾Ø§ÛŒØ§Ù†\nâ€¢ /cancel - Ù„ØºÙˆ")
    else:
        await update.message.reply_text("âŒ ÙÙ‚Ø· ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØµÙˆÛŒØ±ÛŒØŒ ÙˆÛŒØ¯ÛŒÙˆØŒ ØµÙˆØª Ùˆ Ø³Ù†Ø¯.")

    return GET_RESULTS_FILE


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def end_results_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† Ø«Ø¨Øª Ù†ØªØ§ÛŒØ¬ Ùˆ Ø´Ø±ÙˆØ¹ ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    messages = tasks_in_progress[update.effective_user.id].get("results_messages", [])

    # Ø°Ø®ÛŒØ±Ù‡ Ù…ØªÙ† Ù†ØªØ§ÛŒØ¬
    text_parts = [m['content'] for m in messages if m['type'] == 'text']
    tasks_in_progress[update.effective_user.id]["results"] = "\n".join(text_parts) if text_parts else ""

    # Ø´Ø±ÙˆØ¹ ØªÙˆØ¶ÛŒØ­Ø§Øª
    tasks_in_progress[update.effective_user.id]["description_messages"] = []

    await update.message.reply_text(
        "âœ… Ù†ØªØ§ÛŒØ¬ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.\n\n"
        "ğŸ“ ØªÙˆØ¶ÛŒØ­Ø§Øª Ú©Ø§Ø±\n\n"
        "Ù…Ø±Ø­Ù„Ù‡ 1: Ø§Ø±Ø³Ø§Ù„ Ù…ØªÙ†\n"
        "ØªÙˆØ¶ÛŒØ­Ø§Øª Ú©Ø§Ù…Ù„ Ú©Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return GET_DESCRIPTION_TEXT


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def handle_description_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ù…ØªÙ† ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    message_text = update.message.text
    tasks_in_progress[update.effective_user.id]["description_messages"].append({
        'type': 'text',
        'content': message_text
    })

    await update.message.reply_text(
        "âœ… Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ Ù…ØªÙ† Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡\n"
        "â€¢ /send_file - Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return GET_DESCRIPTION_TEXT


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def skip_description_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø±ÙØªÙ† Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ ÙØ§ÛŒÙ„ ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    await update.message.reply_text(
        "Ù…Ø±Ø­Ù„Ù‡ 2: Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„\n\n"
        "ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª:\n"
        "â€¢ /end - Ù¾Ø§ÛŒØ§Ù†\n"
        "â€¢ /cancel - Ù„ØºÙˆ"
    )
    return GET_DESCRIPTION_FILE


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def handle_description_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„ ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    file_info = None
    if update.message.photo:
        file_info = (update.message.photo[-1].file_id, 'photo')
    elif update.message.video:
        file_info = (update.message.video.file_id, 'video')
    elif update.message.voice:
        file_info = (update.message.voice.file_id, 'voice')
    elif update.message.document:
        file_info = (update.message.document.file_id, 'document')

    if file_info:
        tasks_in_progress[update.effective_user.id]["description_messages"].append({
            'type': 'file',
            'file_id': file_info[0],
            'file_type': file_info[1]
        })
        await update.message.reply_text("âœ… ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\nâ€¢ /end - Ù¾Ø§ÛŒØ§Ù†\nâ€¢ /cancel - Ù„ØºÙˆ")
    else:
        await update.message.reply_text("âŒ ÙÙ‚Ø· ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØµÙˆÛŒØ±ÛŒØŒ ÙˆÛŒØ¯ÛŒÙˆØŒ ØµÙˆØª Ùˆ Ø³Ù†Ø¯.")

    return GET_DESCRIPTION_FILE


# ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯
async def end_description_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† Ø«Ø¨Øª ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    messages = tasks_in_progress[update.effective_user.id].get("description_messages", [])

    # Ø°Ø®ÛŒØ±Ù‡ Ù…ØªÙ† ØªÙˆØ¶ÛŒØ­Ø§Øª
    text_parts = [m['content'] for m in messages if m['type'] == 'text']
    tasks_in_progress[update.effective_user.id]["description"] = "\n".join(text_parts) if text_parts else ""

    await update.message.reply_text(
        "âœ… ØªÙˆØ¶ÛŒØ­Ø§Øª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.\n\n"
        "Ø­Ø§Ù„Ø§ Ù…ÛŒØ²Ø§Ù† Ø§Ù‡Ù…ÛŒØª Ú©Ø§Ø± Ø±Ø§ Ù…Ø´Ø®Øµ Ú©Ù†ÛŒØ¯:\n"
        "Û± - Ú©Ù…\n"
        "Û² - Ù…ØªÙˆØ³Ø·\n"
        "Û³ - Ø²ÛŒØ§Ø¯\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )
    return GET_IMPORTANCE


async def get_results(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±."""
    tasks_in_progress[update.effective_user.id]["results"] = update.message.text
    await update.message.reply_text(
        "âœ… Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "Ø­Ø§Ù„Ø§ ØªÙˆØ¶ÛŒØ­Ø§Øª Ú©Ø§Ù…Ù„ Ú©Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )
    return GET_DESCRIPTION


async def get_description(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª ØªÙˆØ¶ÛŒØ­Ø§Øª Ú©Ø§Ø±."""
    tasks_in_progress[update.effective_user.id]["description"] = update.message.text
    await update.message.reply_text(
        "âœ… ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "Ø­Ø§Ù„Ø§ Ù…ÛŒØ²Ø§Ù† Ø§Ù‡Ù…ÛŒØª Ú©Ø§Ø± Ø±Ø§ Ù…Ø´Ø®Øµ Ú©Ù†ÛŒØ¯:\n"
        "Û± - Ú©Ù…\n"
        "Û² - Ù…ØªÙˆØ³Ø·\n"
        "Û³ - Ø²ÛŒØ§Ø¯\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
    )
    return GET_IMPORTANCE


async def get_importance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø§Ù‡Ù…ÛŒØª Ú©Ø§Ø±."""
    try:
        importance = int(update.message.text)
        if not 1 <= importance <= 3:
            raise ValueError
        tasks_in_progress[update.effective_user.id]["importance"] = importance
        await update.message.reply_text(
            "âœ… Ø§Ù‡Ù…ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
            "Ø­Ø§Ù„Ø§ Ø§ÙˆÙ„ÙˆÛŒØª Ú©Ø§Ø± Ø±Ø§ Ù…Ø´Ø®Øµ Ú©Ù†ÛŒØ¯:\n"
            "Û± - Ú©Ù…\n"
            "Û² - Ù…ØªÙˆØ³Ø·\n"
            "Û³ - Ø²ÛŒØ§Ø¯\n\n"
            "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )
        return GET_PRIORITY
    except (ValueError, IndexError):
        await update.message.reply_text(
            "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¹Ø¯Ø¯ Ø¨ÛŒÙ† Û± ØªØ§ Û³ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
            "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )
        return GET_IMPORTANCE


async def get_priority(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø§ÙˆÙ„ÙˆÛŒØª Ú©Ø§Ø±."""
    try:
        priority = int(update.message.text)
        if not 1 <= priority <= 3:
            raise ValueError
        tasks_in_progress[update.effective_user.id]["priority"] = priority

        # Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† Ø§Ø² UserService
        employees = UserService.get_all_employees()

        if not employees:
            await update.message.reply_text("âš ï¸ Ù‡ÛŒÚ† Ú©Ø§Ø±Ù…Ù†Ø¯ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª!")
            return ConversationHandler.END

        keyboard = []
        # employees assumed to be list of dicts with keys like 'telegram_id' and 'name'
        for user in employees:
            telegram_id = user.get('telegram_id') or user.get('telegram_id')
            name = user.get('name')
            keyboard.append([InlineKeyboardButton(name, callback_data=f"assign_{telegram_id}")])

        keyboard.append([InlineKeyboardButton("Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ", callback_data="assign_None")])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "âœ… Ø§ÙˆÙ„ÙˆÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
            "Ø§ÛŒÙ† Ú©Ø§Ø± Ø±Ø§ Ø¨Ù‡ Ú©Ø¯Ø§Ù… Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ®ØµÛŒØµ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒØ¯ØŸ",
            reply_markup=reply_markup
        )

        return SELECT_ASSIGNEE

    except (ValueError, IndexError):
        await update.message.reply_text(
            "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¹Ø¯Ø¯ Ø¨ÛŒÙ† Û± ØªØ§ Û³ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
            "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )
        return GET_PRIORITY


async def get_files(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§."""
    file_info = None
    if update.message.photo:
        file_info = (update.message.photo[-1].file_id, 'photo')
    elif update.message.video:
        file_info = (update.message.video.file_id, 'video')
    elif update.message.voice:
        file_info = (update.message.voice.file_id, 'voice')
    elif update.message.document:
        file_info = (update.message.document.file_id, 'document')

    if file_info:
        tasks_in_progress[update.effective_user.id]["attachments"].append(file_info)
        await update.message.reply_text(
            "âœ… ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
            "Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±ÛŒ Ø¨ÙØ±Ø³ØªÛŒØ¯ ÛŒØ§ Ø¨Ø±Ø§ÛŒ Ø§ØªÙ…Ø§Ù…ØŒ /end Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n\n"
            "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )
    else:
        await update.message.reply_text(
            "âŒ ÙÙ‚Ø· ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØµÙˆÛŒØ±ÛŒØŒ ÙˆÛŒØ¯ÛŒÙˆÛŒÛŒØŒ ØµÙˆØªÛŒ Ùˆ Ø§Ø³Ù†Ø§Ø¯ Ù‚Ø§Ø¨Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù‡Ø³ØªÙ†Ø¯.\n\n"
            "Ø¨Ø±Ø§ÛŒ Ø§ØªÙ…Ø§Ù…ØŒ /end Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯.\n"
            "Ø¨Ø±Ø§ÛŒ Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§ØªØŒ /cancel Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯."
        )

    return GET_FILES


async def end_file_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù‡Ù†Ø¯Ù„Ø± Ù¾Ø§ÛŒØ§Ù† Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„."""

    # Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† Ø§Ø² UserService
    employees = UserService.get_all_employees()

    if not employees:
        await update.message.reply_text(
            "âŒ Ù‡ÛŒÚ† Ú©Ø§Ø±Ù…Ù†Ø¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!\n"
            "Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ£ÛŒÛŒØ¯ Ú©Ù†ÛŒØ¯.\n\n"
            "Ø¹Ù…Ù„ÛŒØ§Øª ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø± Ù„ØºÙˆ Ø´Ø¯."
        )
        return ConversationHandler.END

    # Ø³Ø§Ø®Øª Ú©ÛŒØ¨ÙˆØ±Ø¯
    keyboard = []
    # employees assumed to be list of dicts with keys like 'id','telegram_id','name'
    for user in employees:
        telegram_id = user.get('telegram_id')
        name = user.get('name')
        keyboard.append([InlineKeyboardButton(f"ğŸ‘¤ {name}", callback_data=f"assign_{telegram_id}")])

    keyboard.append([InlineKeyboardButton("ğŸš« Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ", callback_data="assign_None")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "âœ… ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯.\n\n"
        "Ø­Ø§Ù„Ø§ Ù†ÛŒØ±ÙˆÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¨Ø±Ø§ÛŒ ØªØ®ØµÛŒØµ Ø§ÛŒÙ† Ú©Ø§Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=reply_markup
    )
    return SELECT_ASSIGNEE


async def select_assignee(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª ØªØ®ØµÛŒØµ Ùˆ Ø±ÙØªÙ† Ø¨Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ"""
    query = update.callback_query
    await query.answer()

    assignee_telegram_id = query.data.split('_')[1]
    tasks_in_progress[query.from_user.id]["assignee"] = assignee_telegram_id

    # Ù†Ù…Ø§ÛŒØ´ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ Ø§Ø² TaskService
    categories = TaskService.get_categories()

    if not categories:
        await query.edit_message_text(
            "âŒ Ù‡ÛŒÚ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.\n"
            "Ø§Ø¨ØªØ¯Ø§ Ø§Ø² Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒØŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯.\n\n"
            "Ø¹Ù…Ù„ÛŒØ§Øª ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø± Ù„ØºÙˆ Ø´Ø¯."
        )
        return ConversationHandler.END

    keyboard = []
    # categories assumed to be list of dicts with keys 'id' and 'name'
    for cat in categories:
        keyboard.append([InlineKeyboardButton(f"ğŸ“‚ {cat.get('name')}", callback_data=f"select_cat_{cat.get('id')}")])
    keyboard.append([InlineKeyboardButton("ğŸš« Ø¨Ø¯ÙˆÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ", callback_data="select_cat_None")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        "âœ… Ù†ÛŒØ±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯.\n\n"
        "Ø­Ø§Ù„Ø§ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ø§Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=reply_markup
    )

    return SELECT_CATEGORY


async def save_task_with_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø°Ø®ÛŒØ±Ù‡ Ù†Ù‡Ø§ÛŒÛŒ Ú©Ø§Ø± Ø¨Ø§ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ"""
    query = update.callback_query
    await query.answer()

    category_data = query.data.split('_')[2]
    category_id = None if category_data == 'None' else int(category_data)

    task_data = tasks_in_progress.get(query.from_user.id)

    if not task_data:
        await query.edit_message_text("âŒ Ø®Ø·Ø§: Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return ConversationHandler.END

    try:
        # Ø¯Ø±ÛŒØ§ÙØª ID Ø§Ø¯Ù…ÛŒÙ† Ø§Ø² UserService
        admin_telegram_id = query.from_user.id
        admin_user = UserService.get_user_info(admin_telegram_id)
        admin_db_id = admin_user.get('id') if admin_user else None

        # Ø¯Ø±ÛŒØ§ÙØª ID Ú©Ø§Ø±Ù…Ù†Ø¯ (Ø§Ú¯Ø± ØªØ®ØµÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡)
        assigned_to_id = None
        assignee_telegram_id = task_data.get("assignee")

        if assignee_telegram_id and assignee_telegram_id != 'None':
            assignee_user = UserService.get_user_info(int(assignee_telegram_id))
            if assignee_user:
                assigned_to_id = assignee_user.get('id')

        # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ³Ú© Ø¨Ø±Ø§ÛŒ TaskService
        task_payload = {
            'title': task_data['title'],
            'description': task_data.get('description', ''),
            'assigned_to_id': assigned_to_id,
            'assigned_by_id': admin_db_id,
            'duration': task_data.get('duration', ''),
            'results': task_data.get('results', ''),
            'importance': task_data.get('importance'),
            'priority': task_data.get('priority'),
            'status': 'pending',
            'creation_date': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'category_id': category_id
        }

        # Ø§ÛŒØ¬Ø§Ø¯ ØªØ³Ú© Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø³Ø±ÙˆÛŒØ³
        task_id = TaskService.create_task(task_payload)

        # Ø°Ø®ÛŒØ±Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒÙˆØ³Øª Ù‚Ø¯ÛŒÙ…ÛŒ
        for file_id, file_type in task_data.get('attachments', []):
            FileService.add_task_attachment(task_id, file_id, file_type)

        # Ø°Ø®ÛŒØ±Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†ØªØ§ÛŒØ¬ Ùˆ ØªÙˆØ¶ÛŒØ­Ø§Øª
        results_files = [m for m in task_data.get('results_messages', []) if m['type'] == 'file']
        description_files = [m for m in task_data.get('description_messages', []) if m['type'] == 'file']

        for file_msg in results_files + description_files:
            FileService.add_task_attachment(task_id, file_msg['file_id'], file_msg['file_type'])

        # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆÙ‚Øª
        del tasks_in_progress[query.from_user.id]

        # Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ
        keyboard = get_main_menu_keyboard()

        total_files = len(task_data.get('attachments', [])) + len(results_files) + len(description_files)

        await query.edit_message_text(
            f"âœ… Ú©Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯!\n\n"
            f"ğŸ“‹ Ø¹Ù†ÙˆØ§Ù†: {task_data['title']}\n"
            f"â± Ù…Ø¯Øª Ø²Ù…Ø§Ù†: {task_data.get('duration', 'ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡')}\n"
            f"ğŸ“Š Ø§Ù‡Ù…ÛŒØª: {task_data.get('importance', '-')}\n"
            f"ğŸ¯ Ø§ÙˆÙ„ÙˆÛŒØª: {task_data.get('priority', '-')}\n"
            f"ğŸ“ ØªØ¹Ø¯Ø§Ø¯ ÙØ§ÛŒÙ„: {total_files}\n"
            f"ğŸ‘¤ ØªØ®ØµÛŒØµ Ø¨Ù‡: {'ØªØ®ØµÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡' if assigned_to_id else 'Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ'}",
            reply_markup=keyboard
        )

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ú©Ø§Ø±: {e}")
        await query.edit_message_text(
            "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ú©Ø§Ø±!\n\n"
            "Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.",
            reply_markup=get_main_menu_keyboard()
        )

    return ConversationHandler.END


async def cancel_define_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ ÙØ±Ø¢ÛŒÙ†Ø¯ ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±"""

    # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ‚Øª
    user_id = update.effective_user.id
    context.user_data.clear()

    if user_id in tasks_in_progress:
        del tasks_in_progress[user_id]

    # Ø§Ú¯Ø± Ø§Ø² message Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡
    if update.message:
        await update.message.reply_text(
            "âŒ ÙØ±Ø¢ÛŒÙ†Ø¯ ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø± Ù„ØºÙˆ Ø´Ø¯.",
            reply_markup=ReplyKeyboardRemove()
        )
        # Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ
        keyboard = get_main_menu_keyboard()
        await update.message.reply_text(
            "ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:",
            reply_markup=keyboard
        )

    # Ø§Ú¯Ø± Ø§Ø² callback query Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡
    elif update.callback_query:
        query = update.callback_query
        await query.answer()
        keyboard = get_main_menu_keyboard()
        await query.edit_message_text(
            "âŒ ÙØ±Ø¢ÛŒÙ†Ø¯ ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø± Ù„ØºÙˆ Ø´Ø¯.\n\n"
            "ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:",
            reply_markup=keyboard
        )

    return ConversationHandler.END

# Ù‡Ù†Ø¯Ù„Ø± Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±
task_creation_conv_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_task_creation, pattern='^define_task$')
    ],
    states={
        GET_TITLE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_title),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_DURATION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_duration),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_RESULTS_TEXT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_results_text),
            CommandHandler("end", end_results_entry),
            CommandHandler("send_file", skip_results_text),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_RESULTS_FILE: [
            MessageHandler(filters.ATTACHMENT, handle_results_file),
            CommandHandler("end", end_results_entry),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_DESCRIPTION_TEXT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_description_text),
            CommandHandler("end", end_description_entry),
            CommandHandler("send_file", skip_description_text),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_DESCRIPTION_FILE: [
            MessageHandler(filters.ATTACHMENT, handle_description_file),
            CommandHandler("end", end_description_entry),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_IMPORTANCE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_importance),
            CommandHandler("cancel", cancel_define_task)
        ],
        GET_PRIORITY: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, get_priority),
            CommandHandler("cancel", cancel_define_task)
        ],
        SELECT_ASSIGNEE: [
            CallbackQueryHandler(select_assignee, pattern='^assign_'),
            CommandHandler("cancel", cancel_define_task)
        ],
        SELECT_CATEGORY: [
            CallbackQueryHandler(save_task_with_category, pattern='^select_cat_'),
            CommandHandler("cancel", cancel_define_task)
        ]
    },
    fallbacks=[ # ğŸ‘ˆ Ø´Ø±ÙˆØ¹ Ù„ÛŒØ³Øª ÙØ§Ù„â€ŒØ¨Ú©â€ŒÙ‡Ø§
        CommandHandler("cancel", cancel_define_task),
        CallbackQueryHandler(cancel_define_task, pattern='^cancel_define$')
    ], # ğŸ‘ˆ Ù¾Ø§ÛŒØ§Ù† Ù„ÛŒØ³Øª ÙØ§Ù„â€ŒØ¨Ú©â€ŒÙ‡Ø§
    per_message=False,
    per_chat=True,
    per_user=True,
    allow_reentry=True
)

<a id='handlers_admin_edit_task_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 23: handlers\admin\edit_task_handler.py
==================================================

# handlers/admin/edit_task_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, Bot
from telegram.ext import (
    ConversationHandler, ContextTypes, MessageHandler, CallbackQueryHandler, filters, CommandHandler
)
from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService
import datetime

# ÙˆØ¶Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù„Ù…Ù‡
(
    EDIT_SELECT_USER, EDIT_SELECT_TASK, EDIT_GET_TITLE, EDIT_GET_DURATION, EDIT_GET_RESULTS, EDIT_GET_DESCRIPTION,
    EDIT_GET_IMPORTANCE, EDIT_GET_PRIORITY, EDIT_GET_FILES, EDIT_SELECT_ASSIGNEE, EDIT_SELECT_CATEGORY
) = range(8, 19)

# Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆÙ‚Øª
tasks_being_edited = {}


def get_main_menu_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ú©Ø§Ù…Ù„ Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯."""
    keyboard = [
        [InlineKeyboardButton("ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±", callback_data="define_task")],
        [InlineKeyboardButton("ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±", callback_data="edit_task")],
        [InlineKeyboardButton("Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§", callback_data="manage_tasks")],
        [InlineKeyboardButton("Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§", callback_data="categories")]
    ]
    return InlineKeyboardMarkup(keyboard)


async def start_task_editing(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    # Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† (Ù†ÛŒØ±ÙˆÙ‡Ø§)
    employees = context.bot_data['employees']
    keyboard = []

    for telegram_id, name in employees.items():
        keyboard.append([InlineKeyboardButton(name, callback_data=f"edit_user_{telegram_id}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Ú©Ø¯Ø§Ù… Ù†ÛŒØ±Ùˆ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯ØŸ", reply_markup=reply_markup)
    return EDIT_SELECT_USER


async def select_user_for_editing(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒØ´"""
    query = update.callback_query
    await query.answer()

    user_telegram_id = int(query.data.split('_')[2])
    context.user_data['selected_user_telegram_id'] = user_telegram_id

    # Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±
    conn = create_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT id FROM Users WHERE telegram_id = ?", (user_telegram_id,))
    user_db_id = cursor.fetchone()[0]

    cursor.execute("SELECT id, title FROM Tasks WHERE assigned_to_id = ?", (user_db_id,))
    tasks = cursor.fetchall()
    conn.close()

    if not tasks:
        await query.edit_message_text("Ø§ÛŒÙ† Ú©Ø§Ø±Ø¨Ø± Ù‡ÛŒÚ† Ú©Ø§Ø±ÛŒ Ù†Ø¯Ø§Ø±Ø¯.")
        return ConversationHandler.END

    keyboard = []
    for task_id, title in tasks:
        keyboard.append([InlineKeyboardButton(title, callback_data=f"edit_task_{task_id}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Ú©Ø¯Ø§Ù… Ú©Ø§Ø± Ø±Ø§ ÙˆÛŒØ±Ø§ÛŒØ´ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯ØŸ", reply_markup=reply_markup)
    return EDIT_SELECT_TASK


async def select_task_for_editing(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø± Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id

    # Ù†Ù…Ø§ÛŒØ´ Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚Ø§Ø¨Ù„ ÙˆÛŒØ±Ø§ÛŒØ´
    keyboard = [
        [InlineKeyboardButton("Ø¹Ù†ÙˆØ§Ù†", callback_data=f"edit_title_{task_id}")],
        [InlineKeyboardButton("Ù…Ø¯Øª Ø²Ù…Ø§Ù†", callback_data=f"edit_duration_{task_id}")],
        [InlineKeyboardButton("Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±", callback_data=f"edit_results_{task_id}")],
        [InlineKeyboardButton("ØªÙˆØ¶ÛŒØ­Ø§Øª", callback_data=f"edit_description_{task_id}")],
        [InlineKeyboardButton("Ø§Ù‡Ù…ÛŒØª", callback_data=f"edit_importance_{task_id}")],
        [InlineKeyboardButton("Ø§ÙˆÙ„ÙˆÛŒØª", callback_data=f"edit_priority_{task_id}")],
        [InlineKeyboardButton("ÙØ§ÛŒÙ„â€ŒÙ‡Ø§", callback_data=f"edit_files_{task_id}")],
        [InlineKeyboardButton("Ø§Ù†Ø¬Ø§Ù…â€ŒØ¯Ù‡Ù†Ø¯Ù‡", callback_data=f"edit_assignee_{task_id}")],
        [InlineKeyboardButton("Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ", callback_data=f"edit_category_{task_id}")],
        [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")]
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("Ú©Ø¯Ø§Ù… Ù‚Ø³Ù…Øª Ø±Ø§ ÙˆÛŒØ±Ø§ÛŒØ´ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯ØŸ", reply_markup=reply_markup)


# ØªÙˆØ§Ø¨Ø¹ ÙˆÛŒØ±Ø§ÛŒØ´ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
async def edit_title_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ø¹Ù†ÙˆØ§Ù† Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'title'

    await query.edit_message_text("Ø¹Ù†ÙˆØ§Ù† Ø¬Ø¯ÛŒØ¯ Ú©Ø§Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
    return EDIT_GET_TITLE


async def edit_duration_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'duration'

    await query.edit_message_text("Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø¨Ù‡ Ø¯Ù‚ÛŒÙ‚Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
    return EDIT_GET_DURATION


async def edit_results_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'results'

    await query.edit_message_text("Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
    return EDIT_GET_RESULTS


async def edit_description_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'description'

    await query.edit_message_text("ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
    return EDIT_GET_DESCRIPTION


async def edit_importance_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ø§Ù‡Ù…ÛŒØª"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'importance'

    await query.edit_message_text("Ø¯Ø±Ø¬Ù‡ Ø§Ù‡Ù…ÛŒØª Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† Û± ØªØ§ Ûµ):")
    return EDIT_GET_IMPORTANCE


async def edit_priority_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ø§ÙˆÙ„ÙˆÛŒØª"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'priority'

    await query.edit_message_text("Ø§ÙˆÙ„ÙˆÛŒØª Ø¬Ø¯ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† Û± ØªØ§ Û³):")
    return EDIT_GET_PRIORITY


async def edit_files_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'files'
    tasks_being_edited[query.from_user.id] = {"attachments": []}

    await query.edit_message_text(
        "ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯. Ø¨Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ§Ù† '/end' Ø±Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯:"
    )
    return EDIT_GET_FILES


async def edit_assignee_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ø§Ù†Ø¬Ø§Ù…â€ŒØ¯Ù‡Ù†Ø¯Ù‡"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'assignee'

    employees = context.bot_data['employees']
    keyboard = []

    for telegram_id, name in employees.items():
        keyboard.append([InlineKeyboardButton(name, callback_data=f"assign_edit_{telegram_id}")])

    keyboard.append([InlineKeyboardButton("Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ", callback_data="assign_edit_None")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Ø§Ù†Ø¬Ø§Ù…â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:", reply_markup=reply_markup)
    return EDIT_SELECT_ASSIGNEE


async def edit_category_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['edit_task_id'] = task_id
    context.user_data['edit_field'] = 'category'

    conn = create_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT id, name FROM Categories ORDER BY name")
    categories = cursor.fetchall()
    conn.close()

    if not categories:
        await query.edit_message_text("Ù‡ÛŒÚ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡.")
        return ConversationHandler.END

    keyboard = []
    for cat_id, cat_name in categories:
        keyboard.append([InlineKeyboardButton(cat_name, callback_data=f"set_cat_{cat_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:", reply_markup=reply_markup)
    return EDIT_SELECT_CATEGORY


# ØªÙˆØ§Ø¨Ø¹ Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§
async def process_title_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ Ø¹Ù†ÙˆØ§Ù†"""
    new_title = update.message.text
    task_id = context.user_data['edit_task_id']

    conn = create_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE Tasks SET title = ? WHERE id = ?", (new_title, task_id))
    conn.commit()
    conn.close()

    await update.message.reply_text("Ø¹Ù†ÙˆØ§Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
    await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


async def process_duration_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø¯Øª Ø²Ù…Ø§Ù†"""
    try:
        new_duration = int(update.message.text)
        if new_duration <= 0:
            raise ValueError

        task_id = context.user_data['edit_task_id']

        conn = create_connection()
        cursor = conn.cursor()
        cursor.execute("UPDATE Tasks SET duration = ? WHERE id = ?", (str(new_duration), task_id))
        conn.commit()
        conn.close()

        await update.message.reply_text("Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
        await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
        return ConversationHandler.END

    except ValueError:
        await update.message.reply_text("Ù„Ø·ÙØ§ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­ Ù…Ø«Ø¨Øª ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return EDIT_GET_DURATION


async def process_results_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ Ù†ØªØ§ÛŒØ¬"""
    new_results = update.message.text
    task_id = context.user_data['edit_task_id']

    conn = create_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE Tasks SET results = ? WHERE id = ?", (new_results, task_id))
    conn.commit()
    conn.close()

    await update.message.reply_text("Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
    await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


async def process_description_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ ØªÙˆØ¶ÛŒØ­Ø§Øª"""
    new_description = update.message.text
    task_id = context.user_data['edit_task_id']

    conn = create_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE Tasks SET description = ? WHERE id = ?", (new_description, task_id))
    conn.commit()
    conn.close()

    await update.message.reply_text("ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
    await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


async def process_importance_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ Ø§Ù‡Ù…ÛŒØª"""
    try:
        new_importance = int(update.message.text)
        if not 1 <= new_importance <= 5:
            raise ValueError

        task_id = context.user_data['edit_task_id']

        conn = create_connection()
        cursor = conn.cursor()
        cursor.execute("UPDATE Tasks SET importance = ? WHERE id = ?", (new_importance, task_id))
        conn.commit()
        conn.close()

        await update.message.reply_text("Ø¯Ø±Ø¬Ù‡ Ø§Ù‡Ù…ÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
        await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
        return ConversationHandler.END

    except ValueError:
        await update.message.reply_text("Ù„Ø·ÙØ§ Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† Û± ØªØ§ Ûµ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return EDIT_GET_IMPORTANCE


async def process_priority_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ Ø§ÙˆÙ„ÙˆÛŒØª"""
    try:
        new_priority = int(update.message.text)
        if not 1 <= new_priority <= 3:
            raise ValueError

        task_id = context.user_data['edit_task_id']

        conn = create_connection()
        cursor = conn.cursor()
        cursor.execute("UPDATE Tasks SET priority = ? WHERE id = ?", (new_priority, task_id))
        conn.commit()
        conn.close()

        await update.message.reply_text("Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
        await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
        return ConversationHandler.END

    except ValueError:
        await update.message.reply_text("Ù„Ø·ÙØ§ Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† Û± ØªØ§ Û³ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:")
        return EDIT_GET_PRIORITY


async def process_files_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙˆÛŒØ±Ø§ÛŒØ´ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§"""
    file_info = None

    if update.message.photo:
        file_info = (update.message.photo[-1].file_id, 'photo')
    elif update.message.video:
        file_info = (update.message.video.file_id, 'video')
    elif update.message.voice:
        file_info = (update.message.voice.file_id, 'voice')
    elif update.message.document:
        file_info = (update.message.document.file_id, 'document')

    if file_info:
        tasks_being_edited[update.effective_user.id]["attachments"].append(file_info)
        await update.message.reply_text("ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±ÛŒ Ø¨ÙØ±Ø³ØªÛŒØ¯ ÛŒØ§ '/end' Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.")
    else:
        await update.message.reply_text("ÙÙ‚Ø· ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØµÙˆÛŒØ±ÛŒØŒ ÙˆÛŒØ¯ÛŒÙˆÛŒÛŒØŒ ØµÙˆØªÛŒ Ùˆ Ø§Ø³Ù†Ø§Ø¯ Ù‚Ø§Ø¨Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù‡Ø³ØªÙ†Ø¯.")

    return EDIT_GET_FILES


async def end_files_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† ÙˆÛŒØ±Ø§ÛŒØ´ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§"""
    task_id = context.user_data['edit_task_id']
    attachments = tasks_being_edited.pop(update.effective_user.id)["attachments"]

    conn = create_connection()
    cursor = conn.cursor()

    # Ø­Ø°Ù ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ
    cursor.execute("DELETE FROM TaskAttachments WHERE task_id = ?", (task_id,))

    # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
    for file_id, file_type in attachments:
        cursor.execute("INSERT INTO TaskAttachments (task_id, file_id, file_type) VALUES (?, ?, ?)",
                       (task_id, file_id, file_type))

    conn.commit()
    conn.close()

    await update.message.reply_text("ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
    await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


async def save_assignee_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø°Ø®ÛŒØ±Ù‡ ÙˆÛŒØ±Ø§ÛŒØ´ Ø§Ù†Ø¬Ø§Ù…â€ŒØ¯Ù‡Ù†Ø¯Ù‡"""
    query = update.callback_query
    await query.answer()

    assignee_telegram_id = query.data.split('_')[2]
    task_id = context.user_data['edit_task_id']

    assigned_to_db_id = None
    if assignee_telegram_id != "None":
        conn = create_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id FROM Users WHERE telegram_id = ?", (int(assignee_telegram_id),))
        assigned_to_db_id = cursor.fetchone()[0]
        conn.close()

    conn = create_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE Tasks SET assigned_to_id = ? WHERE id = ?", (assigned_to_db_id, task_id))
    conn.commit()
    conn.close()

    await query.edit_message_text("Ø§Ù†Ø¬Ø§Ù…â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
    await context.bot.send_message(chat_id=query.from_user.id, text="Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


async def save_category_edit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø°Ø®ÛŒØ±Ù‡ ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ"""
    query = update.callback_query
    await query.answer()

    category_id = int(query.data.split('_')[2])
    task_id = context.user_data['edit_task_id']

    conn = create_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE Tasks SET category_id = ? WHERE id = ?", (category_id, task_id))
    conn.commit()
    conn.close()

    await query.edit_message_text("Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯.")
    await context.bot.send_message(chat_id=query.from_user.id, text="Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


async def cancel_edit_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±"""
    user_id = update.effective_user.id
    tasks_being_edited.pop(user_id, None)

    await update.message.reply_text("ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø± Ù„ØºÙˆ Ø´Ø¯.")
    await update.message.reply_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu_keyboard())
    return ConversationHandler.END


# ConversationHandler Ø§ØµÙ„ÛŒ
edit_conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_task_editing, pattern='^edit_task$')],
    states={
        EDIT_SELECT_USER: [
            CallbackQueryHandler(select_user_for_editing, pattern='^edit_user_'),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_SELECT_TASK: [
            CallbackQueryHandler(select_task_for_editing, pattern='^edit_task_'),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_TITLE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, process_title_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_DURATION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, process_duration_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_RESULTS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, process_results_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_DESCRIPTION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, process_description_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_IMPORTANCE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, process_importance_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_PRIORITY: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, process_priority_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_GET_FILES: [
            MessageHandler(filters.TEXT & ~filters.COMMAND | filters.ATTACHMENT, process_files_edit),
            CommandHandler("end", end_files_edit),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_SELECT_ASSIGNEE: [
            CallbackQueryHandler(save_assignee_edit, pattern='^assign_edit_'),
            CommandHandler("cancel", cancel_edit_task)
        ],
        EDIT_SELECT_CATEGORY: [
            CallbackQueryHandler(save_category_edit, pattern='^set_cat_'),
            CommandHandler("cancel", cancel_edit_task)
        ]
    },
    fallbacks=[
        CallbackQueryHandler(edit_title_field, pattern='^edit_title_'),
        CallbackQueryHandler(edit_duration_field, pattern='^edit_duration_'),
        CallbackQueryHandler(edit_results_field, pattern='^edit_results_'),
        CallbackQueryHandler(edit_description_field, pattern='^edit_description_'),
        CallbackQueryHandler(edit_importance_field, pattern='^edit_importance_'),
        CallbackQueryHandler(edit_priority_field, pattern='^edit_priority_'),
        CallbackQueryHandler(edit_files_field, pattern='^edit_files_'),
        CallbackQueryHandler(edit_assignee_field, pattern='^edit_assignee_'),
        CallbackQueryHandler(edit_category_field, pattern='^edit_category_'),
        CommandHandler("cancel", cancel_edit_task)
    ],
    per_message=False
)

<a id='handlers_admin_manage_tasks_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 24: handlers\admin\manage_tasks_handler.py
==================================================

# handlers/admin/manage_tasks_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
import datetime

from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService


async def show_manage_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§"""
    query = update.callback_query
    await query.answer()

    try:
        # Refactored: Use TaskService (Rule 4: SELECT status, COUNT(*) FROM Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
        status_counts = TaskService.get_task_status_counts()

        # Refactored: Use TaskService (Rule 4: SELECT COUNT(*) FROM Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
        total_tasks = TaskService.get_active_tasks_count()

        # Refactored: Use TaskService
        # The result format is assumed to be a list of tuples (id, title, name, status)
        recent_tasks = TaskService.get_recent_active_tasks(limit=10)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ù‡Ø§!")
        return

    # Ø³Ø§Ø®Øª Ù…ØªÙ†
    text = "ğŸ“Š **Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§**\n\n"
    text += f"ğŸ“ Ú©Ù„ Ú©Ø§Ø±Ù‡Ø§: {total_tasks}\n"
    text += f"â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±: {status_counts.get('pending', 0)}\n"
    text += f"ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…: {status_counts.get('in_progress', 0)}\n"
    text += f"âœ… ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡: {status_counts.get('completed', 0)}\n"
    text += f"â¸ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡: {status_counts.get('on_hold', 0)}\n\n"

    if recent_tasks:
        text += "**Ø¢Ø®Ø±ÛŒÙ† Ú©Ø§Ø±Ù‡Ø§:**\n"
        for task_id, title, assignee, status in recent_tasks[:5]:
            status_emoji = {
                'pending': 'â³',
                'in_progress': 'ğŸ”„',
                'completed': 'âœ…',
                'on_hold': 'â¸'
            }.get(status, 'â“')
            assignee_name = assignee if assignee else "Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ"
            text += f"{status_emoji} {title} - {assignee_name}\n"

    # Ú©ÛŒØ¨ÙˆØ±Ø¯
    keyboard = [
        [
            InlineKeyboardButton("ğŸ“‹ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ù‡Ø§", callback_data="list_all_tasks"),
            InlineKeyboardButton("â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±", callback_data="list_pending_tasks")
        ],
        [
            InlineKeyboardButton("ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…", callback_data="list_in_progress_tasks"),
            InlineKeyboardButton("âœ… ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡", callback_data="list_completed_tasks_manage")
        ],
        [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")]
    ]

    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')


async def list_tasks_by_status(update: Update, context: ContextTypes.DEFAULT_TYPE, status_filter=None,
                               title="Ù‡Ù…Ù‡ Ú©Ø§Ø±Ù‡Ø§"):
    """ØªØ§Ø¨Ø¹ Ø¹Ù…ÙˆÙ…ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ ÙˆØ¶Ø¹ÛŒØª"""
    query = update.callback_query
    await query.answer()

    try:
        # Refactored: Use TaskService (Rule 4: SELECT * FROM Tasks -> TaskService.list_tasks())
        # The result format is assumed to be a list of tuples (id, title, name, status)
        tasks = TaskService.list_tasks(status_filter=status_filter)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§!")
        return

    if not tasks:
        await query.edit_message_text(
            f"ğŸ“ Ù‡ÛŒÚ† Ú©Ø§Ø±ÛŒ Ø¯Ø± ÙˆØ¶Ø¹ÛŒØª '{title}' ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_tasks")
            ]])
        )
        return

    status_emoji_map = {
        'pending': 'â³',
        'in_progress': 'ğŸ”„',
        'completed': 'âœ…',
        'on_hold': 'â¸'
    }

    text = f"ğŸ“‹ **{title}:** ({len(tasks)} Ú©Ø§Ø±)\n\n"
    keyboard = []

    for task_id, task_title, assignee, status in tasks:
        status_emoji = status_emoji_map.get(status, 'â“')
        assignee_name = assignee if assignee else "Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ"
        keyboard.append([
            InlineKeyboardButton(
                f"{status_emoji} {task_title} - {assignee_name}",
                callback_data=f"view_task_{task_id}"
            )
        ])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_tasks")])

    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def list_all_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ù‡Ù…Ù‡ Ú©Ø§Ø±Ù‡Ø§"""
    await list_tasks_by_status(update, context, status_filter=None, title="Ù‡Ù…Ù‡ Ú©Ø§Ø±Ù‡Ø§")


async def list_pending_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±"""
    await list_tasks_by_status(update, context, status_filter='pending', title="Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±")


async def list_in_progress_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…"""
    await list_tasks_by_status(update, context, status_filter='in_progress', title="Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…")


async def list_completed_tasks_manage(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡"""
    await list_tasks_by_status(update, context, status_filter='completed', title="Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡")


async def view_task_details_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])

    try:
        # Refactored: Use TaskService
        task_info = TaskService.get_task_details_for_admin(task_id)

        # Refactored: Use FileService
        attachments = FileService.get_task_attachments(task_id)  # Assuming this call is here as well

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø±: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø±!")
        return

    if task_info:
        # Assuming TaskService returns a dictionary
        title = task_info.get('title')
        description = task_info.get('description')
        duration = task_info.get('duration')
        results = task_info.get('results')
        importance = task_info.get('importance')
        priority = task_info.get('priority')
        category_name = task_info.get('category_name')
        assigned_to_name = task_info.get('assigned_to_name')
        status = task_info.get('status')
        creation_date = task_info.get('creation_date')
        assigned_to_id = task_info.get('assigned_to_id')

        status_emoji = {
            'pending': 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±',
            'in_progress': 'ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…',
            'completed': 'âœ… ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡',
            'on_hold': 'â¸ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡'
        }.get(status, 'â“ Ù†Ø§Ù…Ø´Ø®Øµ')

        text = f"ğŸ“‹ **{title}**\n\n"
        text += f"ğŸ“œ ØªÙˆØ¶ÛŒØ­Ø§Øª:\n{description or 'Ù†Ø¯Ø§Ø±Ø¯'}\n\n"
        text += f"ğŸ¯ Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: {results or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
        text += f"â± Ù…Ø¯Øª Ø²Ù…Ø§Ù† ØªØ®Ù…ÛŒÙ†ÛŒ: {duration or 'Ù†Ø¯Ø§Ø±Ø¯'} Ø¯Ù‚ÛŒÙ‚Ù‡\n"
        text += f"ğŸ”¥ Ø§Ù‡Ù…ÛŒØª: {importance}/3\n"
        text += f"ğŸ” Ø§ÙˆÙ„ÙˆÛŒØª: {priority}/3\n"
        text += f"ğŸ“‚ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {category_name or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
        text += f"ğŸ‘¤ ÙˆØ§Ú¯Ø°Ø§Ø± Ø´Ø¯Ù‡ Ø¨Ù‡: {assigned_to_name or 'âŒ Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ'}\n"
        text += f"ğŸ“Š ÙˆØ¶Ø¹ÛŒØª: {status_emoji}\n"
        text += f"ğŸ“… ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯: {creation_date}\n"

        # Ú©ÛŒØ¨ÙˆØ±Ø¯
        keyboard = []

        # Ø§ÙØ²ÙˆØ¯Ù† Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ§ÛŒÙ„ Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯
        if attachments:
            keyboard.append([InlineKeyboardButton(f"ğŸ“ Ù…Ø´Ø§Ù‡Ø¯Ù‡ {len(attachments)} Ù¾ÛŒÙˆØ³Øª",
                                                  callback_data=f"show_attachments_{task_id}")])

        # Ø§Ú¯Ø± Ú©Ø§Ø± Ø¨Ø¯ÙˆÙ† ØªØ®ØµÛŒØµ Ø§Ø³ØªØŒ Ø¯Ú©Ù…Ù‡ ØªØ®ØµÛŒØµ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆØ¯
        if not assigned_to_id:
            keyboard.append([InlineKeyboardButton("ğŸ‘¤ ØªØ®ØµÛŒØµ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯", callback_data=f"assign_task_{task_id}")])
        else:
            keyboard.append([InlineKeyboardButton("ğŸ”„ ØªØºÛŒÛŒØ± Ú©Ø§Ø±Ù…Ù†Ø¯", callback_data=f"reassign_task_{task_id}")])

        # Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª
        if status == 'pending':
            keyboard.append([InlineKeyboardButton("â–¶ï¸ Ø´Ø±ÙˆØ¹ Ú©Ø§Ø±", callback_data=f"status_in_progress_{task_id}")])
        elif status == 'in_progress':
            keyboard.append([
                InlineKeyboardButton("âœ… ØªÚ©Ù…ÛŒÙ„", callback_data=f"status_completed_{task_id}"),
                InlineKeyboardButton("â¸ ØªÙˆÙ‚Ù", callback_data=f"status_on_hold_{task_id}")
            ])
        elif status == 'on_hold':
            keyboard.append([InlineKeyboardButton("â–¶ï¸ Ø§Ø¯Ø§Ù…Ù‡ Ú©Ø§Ø±", callback_data=f"status_in_progress_{task_id}")])

        keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_tasks")])

        await query.edit_message_text(
            text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )


async def assign_task_to_employee(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† Ø¨Ø±Ø§ÛŒ ØªØ®ØµÛŒØµ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    context.user_data['assign_task_id'] = task_id

    try:
        # Refactored: Use UserService (Rule 4: SELECT * FROM Users -> UserService Ù…Ù†Ø§Ø³Ø¨)
        # Assuming get_approved_employees returns (name, telegram_id, id) tuples
        employees = UserService.get_approved_employees()

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†!")
        return

    if not employees:
        await query.edit_message_text(
            "âš ï¸ Ù‡ÛŒÚ† Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"view_task_{task_id}")
            ]])
        )
        return

    text = "ğŸ‘¤ **ØªØ®ØµÛŒØµ Ú©Ø§Ø± Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯**\n\n"
    text += "Ú©Ø§Ø±Ù…Ù†Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"

    keyboard = []
    # Note: Using tuple unpacking (name, telegram_id, id) based on likely original structure
    for name, _, emp_id in employees:
        keyboard.append([
            InlineKeyboardButton(name, callback_data=f"select_assignee_{task_id}_{emp_id}")
        ])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"view_task_{task_id}")])

    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def execute_task_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø°Ø®ÛŒØ±Ù‡ ØªØ®ØµÛŒØµ Ú©Ø§Ø± Ùˆ Ø´Ø±ÙˆØ¹ ÙØ¹Ø§Ù„ÛŒØª"""
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    employee_id = int(parts[3])
    task_id = int(parts[2])
    start_date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    try:
        # Refactored: Use UserService (Rule 4: SELECT * FROM Users -> UserService.get_user_info())
        employee_info = UserService.get_user_info(employee_id)
        employee_name = employee_info.get('name')

        if not employee_name:
            await query.edit_message_text("âŒ Ø®Ø·Ø§: Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ù…Ù†Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯.")
            return

        # Refactored: Use TaskService (Rule 4: UPDATE Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
        TaskService.assign_task(
            task_id=task_id,
            employee_id=employee_id,
            start_date=start_date
        )

        # Refactored: Use WorkService (Rule 4: INSERT INTO TaskActivities -> WorkService Ù…Ù†Ø§Ø³Ø¨)
        WorkService.start_task_activity(
            task_id=task_id,
            user_id=employee_id,
            start_time=start_date
        )

        await query.edit_message_text(
            f"âœ… Ú©Ø§Ø± **{task_id}** Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ **{employee_name}** ØªØ®ØµÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯!",
            parse_mode='Markdown'
        )

        # Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ø² 2 Ø«Ø§Ù†ÛŒÙ‡
        import asyncio
        await asyncio.sleep(2)

        # Ø³Ø§Ø®Øª callback_query Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª
        from telegram import Update as TgUpdate
        fake_update = TgUpdate(
            update_id=update.update_id,
            callback_query=query
        )
        fake_update.callback_query.data = f"view_task_{task_id}"

        await view_task_details_admin(fake_update, context)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ®ØµÛŒØµ Ú©Ø§Ø±: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ®ØµÛŒØµ Ú©Ø§Ø±!")


async def change_task_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    new_status = parts[1]
    task_id = int(parts[2])

    try:
        # Refactored: Use TaskService (Rule 4: UPDATE Tasks -> TaskService Ù…Ù†Ø§Ø³Ø¨)
        TaskService.update_task_status(task_id, new_status)

        await query.answer("âœ… ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø± ØªØºÛŒÛŒØ± Ú©Ø±Ø¯!", show_alert=True)

        # Ù†Ù…Ø§ÛŒØ´ Ù…Ø¬Ø¯Ø¯ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø±
        from telegram import Update as TgUpdate
        fake_update = TgUpdate(
            update_id=update.update_id,
            callback_query=query
        )
        fake_update.callback_query.data = f"view_task_{task_id}"

        await view_task_details_admin(fake_update, context)

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±!")

<a id='handlers_admin_menu_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 25: handlers\admin\menu_handler.py
==================================================

# handlers/admin/menu_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
from config import ADMIN_ID
from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService


async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ - Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† ÛŒØ§ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id

    # Ú†Ú© Ø§Ø¯Ù…ÛŒÙ†
    if user_id == ADMIN_ID:
        keyboard = [
            [
                InlineKeyboardButton("â• ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±", callback_data="define_task"),
                InlineKeyboardButton("âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±", callback_data="edit_task")
            ],
            [
                InlineKeyboardButton("ğŸ“‹ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§", callback_data="manage_tasks"),
                InlineKeyboardButton("ğŸ“‚ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§", callback_data="categories")
            ],
            [
                InlineKeyboardButton("âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡", callback_data="completed_tasks"),
                InlineKeyboardButton("ğŸ—„ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡â€ŒÛŒØ§ÙØªÙ‡", callback_data="archived_tasks")
            ],
            [
                InlineKeyboardButton("ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", callback_data="user_management"),
                InlineKeyboardButton("ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡", callback_data="daily_report")
            ]
        ]

        await query.edit_message_text(
            "ğŸ  **Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ - Ù…Ø¯ÛŒØ±ÛŒØª**",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    else:
        # Ù…Ù†ÙˆÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
        user = UserService.get_user_info(user_id)
        if user and user[7] == 1:  # is_employee
            keyboard = [
                [
                    InlineKeyboardButton("ğŸ“ Ú©Ø§Ø±Ù‡Ø§", callback_data="list_tasks"),
                    InlineKeyboardButton("ğŸ—‚ Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø§Ø±Ù‡Ø§", callback_data="archive_tasks")
                ]
            ]

            await query.edit_message_text(
                "ğŸ  **Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ**",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='Markdown'
            )
        else:
            await query.edit_message_text(
                "âŒ Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯."
            )

<a id='handlers_admin_new_manage_tasks_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 26: handlers\admin\new_manage_tasks_handler.py
==================================================

# handlers/admin/new_manage_tasks_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService

async def show_manage_tasks_new(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§"""
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("ğŸ‘¥ Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ø§Ø±Ù…Ù†Ø¯", callback_data="manage_by_employee")],
        [InlineKeyboardButton("ğŸ“‚ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ", callback_data="manage_by_category")],
        [InlineKeyboardButton("â­ï¸ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ù‡Ù…ÛŒØª", callback_data="manage_by_importance")],
        [InlineKeyboardButton("ğŸ” Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§ÙˆÙ„ÙˆÛŒØª", callback_data="manage_by_priority")],
        [InlineKeyboardButton("ğŸ’¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ù…ØªÛŒØ§Ø²", callback_data="manage_by_score")],
        [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data="show_menu")]
    ]

    await query.edit_message_text(
        "ğŸ“Š **Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§**\n\n"
        "Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def manage_by_employee(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† Ø¨Ø§ Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ù‡Ø§"""
    query = update.callback_query
    await query.answer()

    employees = UserService.get_all_employees()

    if not employees:
        await query.edit_message_text(
            "âŒ Ù‡ÛŒÚ† Ú©Ø§Ø±Ù…Ù†Ø¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_tasks")
            ]])
        )
        return

    conn = create_connection()
    keyboard = []

    for emp_id, telegram_id, name in employees:
        try:
            cursor = conn.cursor()

            # ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ú©Ø§Ø±Ù‡Ø§
            cursor.execute("""
                SELECT COUNT(*) FROM Tasks t
                JOIN Users u ON t.assigned_to_id = u.id
                WHERE u.telegram_id = ? AND t.status != 'archived'
            """, (telegram_id,))
            total_tasks = cursor.fetchone()[0]

            # ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØªÙ‡
            cursor.execute("""
                SELECT COUNT(*) FROM Tasks t
                JOIN Users u ON t.assigned_to_id = u.id
                WHERE u.telegram_id = ? AND t.status = 'archived'
            """, (telegram_id,))
            finished_tasks = cursor.fetchone()[0]

            button_text = f"ğŸ‘¤ {name} ({finished_tasks}/{total_tasks})"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"emp_tasks_{telegram_id}")])

        except Exception as e:
            print(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ù…Ù†Ø¯ {name}: {e}")

    conn.close()

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_tasks")])

    await query.edit_message_text(
        "ğŸ‘¥ **Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ø§Ø±Ù…Ù†Ø¯**\n\n"
        "Ú©Ø§Ø±Ù…Ù†Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def show_employee_tasks_by_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯"""
    query = update.callback_query
    await query.answer()

    telegram_id = int(query.data.split('_')[2])

    conn = create_connection()
    if not conn:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³!")
        return

    try:
        cursor = conn.cursor()

        # Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù… Ú©Ø§Ø±Ù…Ù†Ø¯
        cursor.execute("SELECT name FROM Users WHERE telegram_id = ?", (telegram_id,))
        employee_name = cursor.fetchone()[0]

        # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¨Ø§ Ø¢Ù…Ø§Ø±
        cursor.execute("""
            SELECT c.id, c.name, 
                   COUNT(t.id) as total,
                   SUM(CASE WHEN t.status = 'archived' THEN 1 ELSE 0 END) as finished
            FROM Categories c
            JOIN Tasks t ON t.category_id = c.id
            JOIN Users u ON t.assigned_to_id = u.id
            WHERE u.telegram_id = ?
            GROUP BY c.id, c.name
            ORDER BY c.name
        """, (telegram_id,))
        categories = cursor.fetchall()

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª!")
        return
    finally:
        conn.close()

    if not categories:
        await query.edit_message_text(
            f"ğŸ“ Ù‡ÛŒÚ† Ú©Ø§Ø±ÛŒ Ø¨Ø±Ø§ÛŒ **{employee_name}** ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_by_employee")
            ]]),
            parse_mode='Markdown'
        )
        return

    keyboard = []
    for cat_id, cat_name, total, finished in categories:
        finished = finished or 0
        button_text = f"ğŸ“‚ {cat_name} ({finished}/{total})"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"emp_cat_{telegram_id}_{cat_id}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_by_employee")])

    await query.edit_message_text(
        f"ğŸ“‚ **Ú©Ø§Ø±Ù‡Ø§ÛŒ {employee_name}**\n\n"
        f"Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def show_tasks_by_employee_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¯Ø± ÛŒÚ© Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø®Ø§Øµ"""
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    telegram_id = int(parts[2])
    category_id = int(parts[3])

    conn = create_connection()
    if not conn:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³!")
        return

    try:
        cursor = conn.cursor()

        # Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù… Ú©Ø§Ø±Ù…Ù†Ø¯ Ùˆ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ
        cursor.execute("SELECT name FROM Users WHERE telegram_id = ?", (telegram_id,))
        employee_name = cursor.fetchone()[0]

        cursor.execute("SELECT name FROM Categories WHERE id = ?", (category_id,))
        category_name = cursor.fetchone()[0]

        # Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§
        cursor.execute("""
            SELECT t.id, t.title, t.status
            FROM Tasks t
            JOIN Users u ON t.assigned_to_id = u.id
            WHERE u.telegram_id = ? AND t.category_id = ?
            ORDER BY t.creation_date DESC
        """, (telegram_id, category_id))
        tasks = cursor.fetchall()

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§: {e}")
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§!")
        return
    finally:
        conn.close()

    if not tasks:
        await query.edit_message_text(
            f"ğŸ“ Ù‡ÛŒÚ† Ú©Ø§Ø±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"emp_tasks_{telegram_id}")
            ]])
        )
        return

    status_emoji = {
        'pending': 'â³',
        'in_progress': 'ğŸ”„',
        'completed': 'âœ…',
        'on_hold': 'â¸',
        'archived': 'ğŸ—„'
    }

    keyboard = []
    for task_id, title, status in tasks:
        emoji = status_emoji.get(status, 'â“')
        keyboard.append([InlineKeyboardButton(f"{emoji} {title}", callback_data=f"view_task_{task_id}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data=f"emp_tasks_{telegram_id}")])

    await query.edit_message_text(
        f"ğŸ“‹ **{employee_name} - {category_name}**\n\n"
        f"ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Ù‡Ø§: {len(tasks)}",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


# Handler Ù‡Ø§ÛŒ Ù…ÙˆÙ‚Øª Ø¨Ø±Ø§ÛŒ Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡
async def manage_placeholder(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª Ø¨Ø±Ø§ÛŒ Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡"""
    query = update.callback_query
    await query.answer()

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="manage_tasks")]]

    await query.edit_message_text(
        "ğŸš§ **Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡ Ø§Ø³Øª**\n\n"
        "Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ Ø§ÛŒÙ† Ø§Ù…Ú©Ø§Ù† Ø§Ø¶Ø§ÙÙ‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

<a id='handlers_admin_user_management_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 27: handlers\admin\user_management_handler.py
==================================================

# handlers/admin/user_management_handler.py

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from services.user_service import UserService


async def show_user_management_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†"""
    query = update.callback_query
    await query.answer()

    # Ø¯Ø±ÛŒØ§ÙØª Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† (ØºÛŒØ± Ø§Ø² Ø§Ø¯Ù…ÛŒÙ†)
    users = UserService.get_all_users()

    if not users:
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")]]
        await query.edit_message_text(
            "ğŸ‘¥ Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø±ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return

    text = "ğŸ‘¥ **Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†**\n\n"
    text += "Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø«Ø¨Øªâ€ŒØ´Ø¯Ù‡:\n\n"

    keyboard = []
    for user in users:
        status_icon = "âœ…" if user.get('is_employee') == 1 else "â³"
        button_text = f"{status_icon} {user.get('name')}"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"user_{user.get('telegram_id')}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu")])

    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def show_user_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø±Ø¨Ø±"""
    query = update.callback_query
    await query.answer()

    telegram_id = int(query.data.split('_')[1])
    user = UserService.get_user_info(telegram_id)

    if not user:
        await query.edit_message_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return

    text = f"ğŸ‘¤ **Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±**\n\n"
    text += f"ğŸ“ Ù†Ø§Ù…: {user.get('name')}\n"
    text += f"ğŸ“± Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†: {user.get('phone_number') if user.get('phone_number') else 'Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡'}\n"
    text += f"ğŸ†” Telegram ID: {telegram_id}\n"
    text += f"ğŸ“… ØªØ§Ø±ÛŒØ® Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…: {user.get('registration_date')}\n"
    text += f"ğŸ“Š ÙˆØ¶Ø¹ÛŒØª: {'Ú©Ø§Ø±Ù…Ù†Ø¯ âœ…' if user.get('is_employee') == 1 else 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯ â³'}\n"

    if user.get('approved_date'):
        text += f"âœ… ØªØ§Ø±ÛŒØ® ØªØ£ÛŒÛŒØ¯: {user.get('approved_date')}\n"

    keyboard = []

    if user.get('is_employee') == 0:
        keyboard.append([InlineKeyboardButton("âœ… ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯", callback_data=f"approve_{telegram_id}")])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="user_management")])

    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def request_approval_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ£ÛŒÛŒØ¯ Ø¨Ø±Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    query = update.callback_query
    await query.answer()

    telegram_id = int(query.data.split('_')[1])
    user = UserService.get_user_info(telegram_id)

    if not user:
        await query.edit_message_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return

    context.user_data['pending_approval_telegram_id'] = telegram_id

    keyboard = [
        [
            InlineKeyboardButton("âœ… Ø¨Ù„Ù‡ØŒ Ù…Ø·Ù…Ø¦Ù†Ù…", callback_data=f"confirm_approve_{telegram_id}"),
            InlineKeyboardButton("âŒ Ø®ÛŒØ±ØŒ Ø§Ù†ØµØ±Ø§Ù", callback_data="user_management")
        ]
    ]

    phone_info = f"\nğŸ“± {user.get('phone_number')}" if user.get('phone_number') else ""

    await query.edit_message_text(
        f"âš ï¸ **ØªØ£ÛŒÛŒØ¯ Ø¹Ù…Ù„ÛŒØ§Øª**\n\n"
        f"Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯:\n"
        f"ğŸ‘¤ {user.get('name')}{phone_info}\n\n"
        f"Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† **Ú©Ø§Ø±Ù…Ù†Ø¯** ØªØ£ÛŒÛŒØ¯ Ú©Ù†ÛŒØ¯ØŸ",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )


async def confirm_approval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ£ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒ Ùˆ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    query = update.callback_query
    await query.answer()

    telegram_id = int(query.data.split('_')[2])
    user = UserService.get_user_info(telegram_id)

    if not user:
        await query.edit_message_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return

    # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯
    success = UserService.approve_employee(telegram_id)

    if success:
        await query.edit_message_text(
            f"âœ… Ú©Ø§Ø±Ø¨Ø± **{user.get('name')}** Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ¨Ø¯ÛŒÙ„ Ø´Ø¯!",
            parse_mode='Markdown'
        )

        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
        try:
            await context.bot.send_message(
                chat_id=telegram_id,
                text="ğŸ‰ ØªØ¨Ø±ÛŒÚ©! Ø´Ù…Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯ÛŒØ¯.\n\n"
                     "Ø§Ú©Ù†ÙˆÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ø§Ù…Ú©Ø§Ù†Ø§Øª Ø³ÛŒØ³ØªÙ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.\n"
                     "Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ /start Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯."
            )
        except:
            pass
    else:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯!")


<a id='handlers_admin___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 28: handlers\admin\__init__.py
==================================================

# handlers/admin/__init__.py


<a id='handlers_employee_employee_archive_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 29: handlers\employee\employee_archive_handler.py
==================================================

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, Bot
from telegram.ext import ContextTypes
from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService


def get_employee_main_keyboard():
    keyboard = [
        [InlineKeyboardButton("Ú©Ø§Ø±Ù‡Ø§", callback_data="list_tasks")],
        [InlineKeyboardButton("Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø§Ø±Ù‡Ø§", callback_data="archive_tasks")]
    ]
    return InlineKeyboardMarkup(keyboard)


async def show_archived_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    query = update.callback_query
    await query.answer()

    user_telegram_id = query.from_user.id

    conn = create_connection()
    cursor = conn.cursor()

    cursor.execute("SELECT id FROM Users WHERE telegram_id = ?", (user_telegram_id,))
    user_db_id = cursor.fetchone()[0]

    # Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡ Ø¨Ø§ Ø§Ù…ØªÛŒØ§Ø² Ø§Ø¯Ù…ÛŒÙ†
    cursor.execute("""
        SELECT t.id, t.title, COALESCE(ar.admin_score, 'Ø¨Ø¯ÙˆÙ† Ø§Ù…ØªÛŒØ§Ø²') as admin_score
        FROM Tasks t
        LEFT JOIN AdminReviews ar ON t.id = ar.task_id AND ar.review_type = 'score'
        WHERE t.assigned_to_id = ? AND t.status = 'archived'
        ORDER BY t.completion_date DESC
    """, (user_db_id,))

    archived_tasks = cursor.fetchall()
    conn.close()

    if not archived_tasks:
        await query.edit_message_text("Ù‡ÛŒÚ† Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.")
        return

    keyboard = []
    for task_id, title, admin_score in archived_tasks:
        score_text = f"({admin_score})" if admin_score != 'Ø¨Ø¯ÙˆÙ† Ø§Ù…ØªÛŒØ§Ø²' else ""
        keyboard.append([
            InlineKeyboardButton(f"{title} {score_text}", callback_data=f"view_archive_{task_id}")
        ])

    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu_employee")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        f"Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø§Ø±Ù‡Ø§ ({len(archived_tasks)} Ú©Ø§Ø±):",
        reply_markup=reply_markup
    )


async def view_archived_task_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡ Ø¨Ø§ Ù†Ø¸Ø±Ø§Øª Ú©Ø§Ù…Ù„ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[2])
    user_telegram_id = query.from_user.id

    try:
        conn = create_connection()
        cursor = conn.cursor()

        # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
        cursor.execute("""
            SELECT t.title, t.description, t.duration, t.results, t.importance, 
                   t.priority, t.completion_date, c.name as category_name
            FROM Tasks t
            LEFT JOIN Categories c ON t.category_id = c.id
            WHERE t.id = ?
        """, (task_id,))

        task_info = cursor.fetchone()

        if not task_info:
            await query.edit_message_text("âŒ Ú©Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
            conn.close()
            return

        # Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†
        cursor.execute("""
            SELECT review_type, text_content, file_id, file_type, admin_score
            FROM AdminReviews
            WHERE task_id = ?
            ORDER BY review_type
        """, (task_id,))
        admin_reviews = cursor.fetchall()

        # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
        title, description, duration, results, importance, priority, completion_date, category_name = task_info

        message_text = (
            f"ğŸ“‹ **Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡**\n\n"
            f"**Ø¹Ù†ÙˆØ§Ù†:** {title}\n"
            f"**Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ:** {category_name or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**Ù…Ø¯Øª Ø²Ù…Ø§Ù†:** {duration or 'Ù†Ø¯Ø§Ø±Ø¯'} Ø¯Ù‚ÛŒÙ‚Ù‡\n"
            f"**Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±:** {results or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**ØªÙˆØ¶ÛŒØ­Ø§Øª:** {description or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**Ø§Ù‡Ù…ÛŒØª:** {importance or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**Ø§ÙˆÙ„ÙˆÛŒØª:** {priority or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**ØªØ§Ø±ÛŒØ® ØªÚ©Ù…ÛŒÙ„:** {completion_date}\n"
            f"{'â€”' * 20}\n"
            f"**Ù†Ø¸Ø±Ø§Øª Ù…Ø¯ÛŒØ±:**\n"
        )

        await query.edit_message_text(message_text, parse_mode='Markdown')

        # Ø§Ú¯Ø± Ù†Ø¸Ø±ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ ÙÙ‚Ø· Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª Ùˆ Ù…ØªÙ† Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø¯
        if not admin_reviews:
            keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¢Ø±Ø´ÛŒÙˆ", callback_data="archive_tasks")]]
            await context.bot.send_message(
                chat_id=user_telegram_id,
                text="âš ï¸ Ù†Ø¸Ø± Ù…Ø¯ÛŒØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø± Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            return

        # Ø§Ø±Ø³Ø§Ù„ Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø§ Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ
        review_types = {
            'opinion': 'ğŸ’­ Ù†Ø¸Ø± Ú©Ù„ÛŒ Ù…Ø¯ÛŒØ±',
            'positive': 'âœ… Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª',
            'negative': 'âŒ Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ',
            'suggestion': 'ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù…Ø¯ÛŒØ±',
            'score': 'â­ Ø§Ù…ØªÛŒØ§Ø² Ù…Ø¯ÛŒØ±'
        }

        # Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ø¸Ø±Ø§Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹
        grouped_reviews = {}
        for review_type, text_content, file_id, file_type, admin_score in admin_reviews:
            if review_type not in grouped_reviews:
                grouped_reviews[review_type] = []
            grouped_reviews[review_type].append({
                'text': text_content,
                'file_id': file_id,
                'file_type': file_type,
                'score': admin_score
            })

        # Ø§Ø±Ø³Ø§Ù„ Ù†Ø¸Ø±Ø§Øª Ø¨Ù‡ ØªØ±ØªÛŒØ¨
        for review_key, review_title in review_types.items():
            if review_key in grouped_reviews:
                review_data = grouped_reviews[review_key]

                if review_key == 'score':
                    # Ø§Ù…ØªÛŒØ§Ø² ÙÙ‚Ø· Ù…ØªÙ† Ø§Ø³Øª
                    score = review_data[0].get('score', 'Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡')
                    await context.bot.send_message(
                        chat_id=user_telegram_id,
                        text=f"**{review_title}**: `{score}/10`",
                        parse_mode='Markdown'
                    )
                    continue

                await context.bot.send_message(
                    chat_id=user_telegram_id,
                    text=f"**{review_title}**:",
                    parse_mode='Markdown'
                )

                for item in review_data:
                    if item['text']:
                        await context.bot.send_message(
                            chat_id=user_telegram_id,
                            text=item['text']
                        )

                    if item['file_id']:
                        try:
                            file_type = item['file_type']
                            if file_type == 'photo':
                                await context.bot.send_photo(chat_id=user_telegram_id, photo=item['file_id'])
                            elif file_type == 'video':
                                await context.bot.send_video(chat_id=user_telegram_id, video=item['file_id'])
                            elif file_type == 'voice':
                                await context.bot.send_voice(chat_id=user_telegram_id, voice=item['file_id'])
                            elif file_type == 'document':
                                await context.bot.send_document(chat_id=user_telegram_id, document=item['file_id'])
                        except Exception as e:
                            print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")
                            await context.bot.send_message(
                                chat_id=user_telegram_id,
                                text=f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„"
                            )

        # Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¢Ø±Ø´ÛŒÙˆ", callback_data="archive_tasks")]]
        await context.bot.send_message(
            chat_id=user_telegram_id,
            text="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± view_archived_task_details: {e}")
        import traceback
        traceback.print_exc()

        try:
            await query.edit_message_text(
                f"âŒ **Ø®Ø·Ø§ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ø¬Ø²Ø¦ÛŒØ§Øª**\n\n"
                f"Ø®Ø·Ø§: {str(e)}\n\n"
                f"Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.",
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup([[ \
                    InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="archive_tasks")
                ]])
            )
        except:
            await context.bot.send_message(
                chat_id=user_telegram_id,
                text=f"âŒ Ø®Ø·Ø§: {str(e)}",
                reply_markup=InlineKeyboardMarkup([[ \
                    InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="archive_tasks")
                ]])
            )
    finally:
        if conn:
            conn.close()

<a id='handlers_employee_employee_task_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 30: handlers\employee\employee_task_handler.py
==================================================

# handlers/employee/employee_task_handler.py

import datetime
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes, ConversationHandler, CallbackQueryHandler, CommandHandler

from database.connection import create_connection
from services.user_service import UserService
from services.task_service import TaskService

# --- ÙˆØ¶Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ú©Ø§Ù„Ù…Ù‡ ---
TASK_START_CONFIRMATION, TASK_WORK_VIEW = range(10, 12)

tasks_in_progress = {}


def get_employee_main_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ Ù…Ø®ØµÙˆØµ Ù†ÛŒØ±ÙˆÙ‡Ø§"""
    keyboard = [
        [InlineKeyboardButton("ğŸ“ Ú©Ø§Ø±Ù‡Ø§", callback_data="list_tasks")],
        [InlineKeyboardButton("ğŸ—‚ Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø§Ø±Ù‡Ø§", callback_data="archive_tasks")]
    ]
    return InlineKeyboardMarkup(keyboard)


def get_active_task_id(user_db_id):
    """ÛŒØ§ÙØªÙ† Ú©Ø§Ø± ÙØ¹Ø§Ù„ Ú©Ø§Ø±Ø¨Ø±"""
    conn = create_connection()
    if not conn:
        return None

    try:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT task_id FROM TaskActivities 
            WHERE user_id = ? AND end_time IS NULL 
            LIMIT 1
        """, (user_db_id,))
        result = cursor.fetchone()
        return result[0] if result else None
    finally:
        conn.close()


async def back_to_tasks_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ÙÙ‡Ø±Ø³Øª Ú©Ø§Ø±Ù‡Ø§"""
    query = update.callback_query
    await query.answer()
    await list_employee_tasks(update, context)
    return ConversationHandler.END


async def cancel_task_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ Ù…Ú©Ø§Ù„Ù…Ù‡ Ø´Ø±ÙˆØ¹ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("âŒ Ø´Ø±ÙˆØ¹ Ú©Ø§Ø± Ù„ØºÙˆ Ø´Ø¯.")
    await list_employee_tasks(update, context)
    return ConversationHandler.END


async def list_employee_tasks(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø§Ø®ØªØµØ§Øµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¨Ù‡ Ù†ÛŒØ±Ùˆ"""
    query = update.callback_query
    await query.answer()

    user_telegram_id = query.from_user.id

    conn = create_connection()
    if not conn:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³!")
        return

    cursor = conn.cursor()

    cursor.execute("SELECT id FROM Users WHERE telegram_id = ?", (user_telegram_id,))
    result = cursor.fetchone()
    if not result:
        conn.close()
        await query.edit_message_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return

    user_db_id = result[0]

    # ÙÙ‚Ø· Ú©Ø§Ø±Ù‡Ø§ÛŒ pending Ùˆ in_progress
    cursor.execute("""
        SELECT id, title, status FROM Tasks 
        WHERE assigned_to_id = ? AND status IN ('pending', 'in_progress')
        ORDER BY status DESC
    """, (user_db_id,))
    tasks = cursor.fetchall()

    # Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø± ÙØ¹Ø§Ù„
    active_task_id = get_active_task_id(user_db_id)

    conn.close()

    if not tasks:
        await query.edit_message_text("ğŸ“­ Ù‡ÛŒÚ† Ú©Ø§Ø± ÙØ¹Ø§Ù„ÛŒ Ø¨Ù‡ Ø´Ù…Ø§ Ù…Ø­ÙˆÙ„ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.")
        return

    keyboard = []
    for task_id, task_title, status in tasks:
        if task_id == active_task_id:
            title_display = f"ğŸŸ¢ {task_title}"
        else:
            title_display = f"ğŸ“Œ {task_title}"

        row = [
            InlineKeyboardButton("ğŸ“‹ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡", callback_data=f"details_{task_id}"),
            InlineKeyboardButton(title_display, callback_data=f"work_panel_{task_id}")
        ]
        keyboard.append(row)

    keyboard.append([InlineKeyboardButton("ğŸ—‚ Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø§Ø±Ù‡Ø§", callback_data="archive_tasks")])
    keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu_employee")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("ğŸ“ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø­ÙˆÙ„â€ŒØ´Ø¯Ù‡ Ø¨Ù‡ Ø´Ù…Ø§:", reply_markup=reply_markup)


async def view_task_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ù…Ù„ Ú©Ø§Ø± Ø¨Ø§ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[1])
    user_telegram_id = query.from_user.id

    conn = create_connection()
    if not conn:
        await query.edit_message_text("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³!")
        return

    cursor = conn.cursor()

    cursor.execute("""
        SELECT t.title, t.description, t.duration, t.results, t.importance, 
               t.priority, t.creation_date, c.name as category_name
        FROM Tasks t
        LEFT JOIN Categories c ON t.category_id = c.id
        WHERE t.id = ?
    """, (task_id,))
    task_info = cursor.fetchone()

    cursor.execute("SELECT file_id, file_type FROM TaskAttachments WHERE task_id = ?", (task_id,))
    attachments = cursor.fetchall()

    conn.close()

    if task_info:
        title, description, duration, results, importance, priority, creation_date, category_name = task_info

        message_text = (
            f"ğŸ“‹ **Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø±**\n\n"
            f"**Ø¹Ù†ÙˆØ§Ù†:** {title}\n"
            f"**Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ:** {category_name or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**Ù…Ø¯Øª Ø²Ù…Ø§Ù†:** {duration or 'Ù†Ø¯Ø§Ø±Ø¯'} Ø¯Ù‚ÛŒÙ‚Ù‡\n"
            f"**Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±:** {results or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**ØªÙˆØ¶ÛŒØ­Ø§Øª:** {description or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**Ø§Ù‡Ù…ÛŒØª:** {importance or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**Ø§ÙˆÙ„ÙˆÛŒØª:** {priority or 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"**ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯:** {creation_date}\n"
        )

        await query.edit_message_text(message_text, parse_mode='Markdown')

        # Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
        if attachments:
            await context.bot.send_message(chat_id=user_telegram_id, text="ğŸ“ **ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒÙˆØ³Øª:**",
                                           parse_mode='Markdown')
            for file_id, file_type in attachments:
                try:
                    if file_type == 'photo':
                        await context.bot.send_photo(chat_id=user_telegram_id, photo=file_id)
                    elif file_type == 'video':
                        await context.bot.send_video(chat_id=user_telegram_id, video=file_id)
                    elif file_type == 'voice':
                        await context.bot.send_voice(chat_id=user_telegram_id, voice=file_id)
                    elif file_type == 'document':
                        await context.bot.send_document(chat_id=user_telegram_id, document=file_id)
                except Exception as e:
                    await context.bot.send_message(
                        chat_id=user_telegram_id,
                        text=f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {str(e)}"
                    )
        else:
            await context.bot.send_message(chat_id=user_telegram_id, text="ğŸ“ ÙØ§ÛŒÙ„ Ù¾ÛŒÙˆØ³ØªÛŒ Ù†Ø¯Ø§Ø±Ø¯.")

        # Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø²Ú¯Ø´Øª
        keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ú©Ø§Ø±Ù‡Ø§", callback_data="list_tasks")]]
        await context.bot.send_message(
            chat_id=user_telegram_id,
            text="Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )


async def employee_fallback_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ Ø¹Ù…Ù„ÛŒØ§Øª"""
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.")
    else:
        await update.message.reply_text("âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯.")
    return ConversationHandler.END


employee_conv_handler = ConversationHandler(
    entry_points=[],
    states={
        TASK_START_CONFIRMATION: [
            CallbackQueryHandler(cancel_task_start, pattern='^cancel_start_task$')
        ],
        TASK_WORK_VIEW: []
    },
    fallbacks=[
        CommandHandler("cancel", employee_fallback_cancel),
        CallbackQueryHandler(employee_fallback_cancel, pattern='^cancel_employee$')
    ],
    per_message=False,
    per_chat=True,
    per_user=True,
    allow_reentry=True
)


<a id='handlers_employee_employee_work_handler_py'></a>
==================================================
# Ø¨Ø®Ø´ 31: handlers\employee\employee_work_handler.py
==================================================

# handlers/employee/employee_work_handler.py

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes, ConversationHandler, CommandHandler,
    MessageHandler, CallbackQueryHandler, filters
)

from services.task_service import TaskService
from services.work_service import WorkService
from utils.constants import (
    WORK_KNOWLEDGE_ENTRY, WORK_SUGGESTION_ENTRY, WORK_RESULTS_ENTRY,
    WORK_SELF_SCORE_ENTRY
)
from utils.keyboards import get_task_work_keyboard, get_back_to_tasks_keyboard
from utils.formatters import format_time


# ==================== Helper Functions ====================

def get_work_entry_keyboard(action: str = "finish"):
    """
    Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø±Ø§ÛŒ Ø­ÛŒÙ† ÙˆØ±ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ

    Args:
        action: Ù†ÙˆØ¹ Ø¯Ú©Ù…Ù‡ ('finish' ÛŒØ§ 'cancel')
    """
    keyboard = [
        [InlineKeyboardButton("âœ… Ø§ØªÙ…Ø§Ù… Ùˆ Ø°Ø®ÛŒØ±Ù‡", callback_data=f"finish_{action}")],
        [InlineKeyboardButton("ğŸ  Ø¨Ø§Ø²Ú¯Ø´Øª (Ø¨Ø¯ÙˆÙ† Ø°Ø®ÛŒØ±Ù‡)", callback_data="cancel_work_entry")]
    ]
    return InlineKeyboardMarkup(keyboard)


async def send_file_to_user(context: ContextTypes.DEFAULT_TYPE, chat_id: int, file_id: str, file_type: str):
    """Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹"""
    try:
        if file_type == 'photo':
            await context.bot.send_photo(chat_id=chat_id, photo=file_id)
        elif file_type == 'video':
            await context.bot.send_video(chat_id=chat_id, video=file_id)
        elif file_type == 'voice':
            await context.bot.send_voice(chat_id=chat_id, voice=file_id)
        elif file_type == 'document':
            await context.bot.send_document(chat_id=chat_id, document=file_id)
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")


async def display_previous_entries(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                   task_id: int, user_id: int, data_type: str):
    """Ù†Ù…Ø§ÛŒØ´ Ù…ÙˆØ§Ø±Ø¯ Ù‚Ø¨Ù„ÛŒ Ø«Ø¨Øª Ø´Ø¯Ù‡"""

    # Ø¨Ø±Ø§ÛŒ Ø§Ù…ØªÛŒØ§Ø² Ø§Ø² Ø¬Ø¯ÙˆÙ„ TaskScores Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    if data_type == 'self_score':
        previous_score = WorkService.get_self_score(task_id, user_id)

        if not previous_score:
            await update.callback_query.message.reply_text("â­ Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ† Ø§Ù…ØªÛŒØ§Ø²ÛŒ Ø«Ø¨Øª Ù†Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯.")
            return

        score = previous_score.get('self_score', 0)
        timestamp = previous_score.get('timestamp', 'Ù†Ø§Ù…Ø´Ø®Øµ')
        stars = "â­" * (score // 2) if score > 0 else ""

        await update.callback_query.message.reply_text(
            f"â­ Ø§Ù…ØªÛŒØ§Ø² Ù‚Ø¨Ù„ÛŒ Ø´Ù…Ø§:\n\n"
            f"Ø§Ù…ØªÛŒØ§Ø²: {stars} {score}/10\n"
            f"ØªØ§Ø±ÛŒØ®: {timestamp}\n\n"
            f"Ø§Ù…ØªÛŒØ§Ø² Ø¬Ø¯ÛŒØ¯ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø² Ù‚Ø¨Ù„ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯."
        )
        return

    # Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ù†Ø´ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ØŒ Ù†ØªØ§ÛŒØ¬ Ø§Ø² TaskWorkData
    from database.models.task_work_data import TaskWorkDataModel

    # ØªÙ†Ø¸ÛŒÙ… Ø¹Ù†ÙˆØ§Ù† Ùˆ Ù¾ÛŒØ§Ù… Ø®Ø§Ù„ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹
    type_config = {
        'knowledge': {
            'title': 'ğŸ“š Ø¯Ø§Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø´Ù…Ø§',
            'empty_msg': 'ğŸ“š Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ† Ø¯Ø§Ù†Ø´ÛŒ Ø«Ø¨Øª Ù†Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯.',
        },
        'suggestion': {
            'title': 'ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø´Ù…Ø§',
            'empty_msg': 'ğŸ’¡ Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ Ø«Ø¨Øª Ù†Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯.',
        },
        'results': {
            'title': 'ğŸ“Š Ù†ØªØ§ÛŒØ¬ Ù‚Ø¨Ù„ÛŒ Ø´Ù…Ø§',
            'empty_msg': 'ğŸ“Š Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ† Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ Ø«Ø¨Øª Ù†Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯.',
        }
    }

    config = type_config.get(data_type)
    if not config:
        return

    # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
    previous_data = TaskWorkDataModel.get_by_task_and_user(task_id, user_id, data_type)

    if not previous_data:
        await update.callback_query.message.reply_text(config['empty_msg'])
        return

    # Ø§Ø±Ø³Ø§Ù„ Ø¹Ù†ÙˆØ§Ù†
    await update.callback_query.message.reply_text(f"{config['title']}:\n")

    # Ø§Ø±Ø³Ø§Ù„ Ù‡Ø± Ù…ÙˆØ±Ø¯
    for idx, item in enumerate(previous_data, 1):
        timestamp = item.get('timestamp', 'Ø¨Ø¯ÙˆÙ† ØªØ§Ø±ÛŒØ®')
        text_content = item.get('text_content')
        file_id = item.get('file_id')
        file_type = item.get('file_type')

        # Ø§Ø±Ø³Ø§Ù„ Ù…ØªÙ†
        if text_content:
            await update.callback_query.message.reply_text(
                f"#{idx} - {timestamp}\n{text_content}"
            )

        # Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„
        if file_id and file_type:
            await send_file_to_user(context, update.effective_chat.id, file_id, file_type)


# ==================== Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ú©Ø§Ø±ÛŒ ====================

async def show_task_work_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    # Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
    task = TaskService.get_task(task_id, with_details=True)
    if not task:
        await query.edit_message_text("âŒ Ú©Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return

    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ù…Ø§Ù†
    allocated_time = int(task.get('duration', 0)) if task.get('duration') else 0
    spent_time = 0  # TODO: Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø² TaskActivities

    # Ù†Ù…Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
    text = f"ğŸ“‹ {task.get('title')}\n\n"
    text += f"â± Ø²Ù…Ø§Ù† ØªØ®ØµÛŒØµÛŒ: {format_time(allocated_time)}\n"
    text += f"âŒš Ø²Ù…Ø§Ù† Ø³Ù¾Ø±ÛŒ Ø´Ø¯Ù‡: {format_time(spent_time)}\n\n"
    text += "Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"

    await query.edit_message_text(
        text,
        reply_markup=get_task_work_keyboard(task_id, allocated_time, spent_time)
    )


# ==================== Ø´Ø±ÙˆØ¹ Ú©Ø§Ø± ====================

async def start_work_timer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ØªØ§ÛŒÙ…Ø± Ú©Ø§Ø±"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])

    # TODO: Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù„Ø§Ø¬ÛŒÚ© ØªØ§ÛŒÙ…Ø±
    await query.edit_message_text(
        "ğŸš€ ØªØ§ÛŒÙ…Ø± Ú©Ø§Ø± Ø´Ø±ÙˆØ¹ Ø´Ø¯!\n\n"
        "Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡ Ø§Ø³Øª.",
        reply_markup=get_back_to_tasks_keyboard()
    )


# ==================== Ø«Ø¨Øª Ø¯Ø§Ù†Ø´ ====================

async def start_knowledge_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø«Ø¨Øª Ø¯Ø§Ù†Ø´"""
    from database.models.user import UserModel

    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await query.message.reply_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return ConversationHandler.END

    user_id = user.get('id')

    # Ø°Ø®ÛŒØ±Ù‡ task_id Ø¯Ø± context
    context.user_data['current_task_id'] = task_id
    context.user_data['work_data_buffer'] = []

    # Ù†Ù…Ø§ÛŒØ´ Ù…ÙˆØ§Ø±Ø¯ Ù‚Ø¨Ù„ÛŒ
    await display_previous_entries(update, context, task_id, user_id, 'knowledge')

    # Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¯Ø§Ø¯Ù‡
    await query.message.reply_text(
        "ğŸ“š Ø«Ø¨Øª Ø¯Ø§Ù†Ø´ Ø¬Ø¯ÛŒØ¯\n\n"
        "Ø­Ø§Ù„Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¯Ø§Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n"
        "â€¢ Ù…ØªÙ† Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯\n"
        "â€¢ Ø¹Ú©Ø³ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ–¼\n"
        "â€¢ ÙˆÛŒØ¯ÛŒÙˆ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ¥\n"
        "â€¢ ÙØ§ÛŒÙ„ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ“„\n"
        "â€¢ ØµØ¯Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ¤\n\n"
        "Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ú†Ù†Ø¯ÛŒÙ† Ù…ÙˆØ±Ø¯ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n"
        "ÙˆÙ‚ØªÛŒ ØªÙ…Ø§Ù… Ø´Ø¯ØŒ Ø¯Ø³ØªÙˆØ± /done Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯."
    )

    return WORK_KNOWLEDGE_ENTRY


async def receive_knowledge_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ù†Ø´ (Ù…ØªÙ† ÛŒØ§ ÙØ§ÛŒÙ„)"""
    message = update.message
    user_data = context.user_data.get('work_data_buffer', [])

    # Ø¯Ø±ÛŒØ§ÙØª Ù…ØªÙ†
    if message.text:
        user_data.append({
            'type': 'text',
            'content': message.text
        })
        await message.reply_text("âœ… Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª Ø¹Ú©Ø³
    elif message.photo:
        file_id = message.photo[-1].file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'photo'
        })
        await message.reply_text("âœ… Ø¹Ú©Ø³ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¯ÛŒÙˆ
    elif message.video:
        file_id = message.video.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'video'
        })
        await message.reply_text("âœ… ÙˆÛŒØ¯ÛŒÙˆ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ØµØ¯Ø§
    elif message.voice:
        file_id = message.voice.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'voice'
        })
        await message.reply_text("âœ… ØµØ¯Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„
    elif message.document:
        file_id = message.document.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'document'
        })
        await message.reply_text("âœ… ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    context.user_data['work_data_buffer'] = user_data
    return WORK_KNOWLEDGE_ENTRY


async def finish_knowledge_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ù†Ø´"""
    from database.models.user import UserModel

    task_id = context.user_data.get('current_task_id')
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await update.message.reply_text(
            "âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    user_id = user.get('id')
    work_data = context.user_data.get('work_data_buffer', [])

    if not work_data:
        await update.message.reply_text(
            "âŒ Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    # Ø°Ø®ÛŒØ±Ù‡ Ù‡Ø± Ù…ÙˆØ±Ø¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    saved_count = 0
    for item in work_data:
        if item['type'] == 'text':
            result = WorkService.add_knowledge(task_id, user_id, text_content=item['content'])
        else:
            result = WorkService.add_knowledge(
                task_id, user_id,
                file_id=item['file_id'],
                file_type=item['file_type']
            )

        if result:
            saved_count += 1

    # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø¨Ø§ÙØ±
    context.user_data.pop('work_data_buffer', None)
    context.user_data.pop('current_task_id', None)

    await update.message.reply_text(
        f"âœ… {saved_count} Ù…ÙˆØ±Ø¯ Ø¯Ø§Ù†Ø´ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯!",
        reply_markup=get_back_to_tasks_keyboard()
    )

    return ConversationHandler.END


# ==================== Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ ====================

async def start_suggestion_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯"""
    from database.models.user import UserModel

    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await query.message.reply_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return ConversationHandler.END

    user_id = user.get('id')

    # Ø°Ø®ÛŒØ±Ù‡ task_id Ø¯Ø± context
    context.user_data['current_task_id'] = task_id
    context.user_data['work_data_buffer'] = []

    # Ù†Ù…Ø§ÛŒØ´ Ù…ÙˆØ§Ø±Ø¯ Ù‚Ø¨Ù„ÛŒ
    await display_previous_entries(update, context, task_id, user_id, 'suggestion')

    # Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¯Ø§Ø¯Ù‡
    await query.message.reply_text(
        "ğŸ’¡ Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¬Ø¯ÛŒØ¯\n\n"
        "Ø­Ø§Ù„Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n"
        "â€¢ Ù…ØªÙ† Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯\n"
        "â€¢ Ø¹Ú©Ø³ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ–¼\n"
        "â€¢ ÙˆÛŒØ¯ÛŒÙˆ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ¥\n"
        "â€¢ ÙØ§ÛŒÙ„ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ“„\n"
        "â€¢ ØµØ¯Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ¤\n\n"
        "Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ú†Ù†Ø¯ÛŒÙ† Ù…ÙˆØ±Ø¯ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n"
        "ÙˆÙ‚ØªÛŒ ØªÙ…Ø§Ù… Ø´Ø¯ØŒ Ø¯Ø³ØªÙˆØ± /done Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯."
    )

    return WORK_SUGGESTION_ENTRY


async def receive_suggestion_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯"""
    message = update.message
    user_data = context.user_data.get('work_data_buffer', [])

    # Ø¯Ø±ÛŒØ§ÙØª Ù…ØªÙ†
    if message.text:
        user_data.append({
            'type': 'text',
            'content': message.text
        })
        await message.reply_text("âœ… Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª Ø¹Ú©Ø³
    elif message.photo:
        file_id = message.photo[-1].file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'photo'
        })
        await message.reply_text("âœ… Ø¹Ú©Ø³ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¯ÛŒÙˆ
    elif message.video:
        file_id = message.video.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'video'
        })
        await message.reply_text("âœ… ÙˆÛŒØ¯ÛŒÙˆ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ØµØ¯Ø§
    elif message.voice:
        file_id = message.voice.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'voice'
        })
        await message.reply_text("âœ… ØµØ¯Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„
    elif message.document:
        file_id = message.document.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'document'
        })
        await message.reply_text("âœ… ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    context.user_data['work_data_buffer'] = user_data
    return WORK_SUGGESTION_ENTRY


async def finish_suggestion_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯"""
    from database.models.user import UserModel

    task_id = context.user_data.get('current_task_id')
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await update.message.reply_text(
            "âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    user_id = user.get('id')
    work_data = context.user_data.get('work_data_buffer', [])

    if not work_data:
        await update.message.reply_text(
            "âŒ Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    # Ø°Ø®ÛŒØ±Ù‡ Ù‡Ø± Ù…ÙˆØ±Ø¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    saved_count = 0
    for item in work_data:
        if item['type'] == 'text':
            result = WorkService.add_suggestion(task_id, user_id, text_content=item['content'])
        else:
            result = WorkService.add_suggestion(
                task_id, user_id,
                file_id=item['file_id'],
                file_type=item['file_type']
            )

        if result:
            saved_count += 1

    # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø¨Ø§ÙØ±
    context.user_data.pop('work_data_buffer', None)
    context.user_data.pop('current_task_id', None)

    await update.message.reply_text(
        f"âœ… {saved_count} Ù…ÙˆØ±Ø¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯!",
        reply_markup=get_back_to_tasks_keyboard()
    )

    return ConversationHandler.END


# ==================== Ø«Ø¨Øª Ù†ØªØ§ÛŒØ¬ ====================

async def start_results_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø«Ø¨Øª Ù†ØªØ§ÛŒØ¬"""
    from database.models.user import UserModel

    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await query.message.reply_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return ConversationHandler.END

    user_id = user.get('id')

    # Ø°Ø®ÛŒØ±Ù‡ task_id Ø¯Ø± context
    context.user_data['current_task_id'] = task_id
    context.user_data['work_data_buffer'] = []

    # Ù†Ù…Ø§ÛŒØ´ Ù…ÙˆØ§Ø±Ø¯ Ù‚Ø¨Ù„ÛŒ
    await display_previous_entries(update, context, task_id, user_id, 'results')

    # Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¯Ø§Ø¯Ù‡
    await query.message.reply_text(
        "ğŸ“Š Ø«Ø¨Øª Ù†ØªØ§ÛŒØ¬ Ø¬Ø¯ÛŒØ¯\n\n"
        "Ø­Ø§Ù„Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù†ØªØ§ÛŒØ¬ Ú©Ø§Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n"
        "â€¢ Ù…ØªÙ† Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯\n"
        "â€¢ Ø¹Ú©Ø³ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ–¼\n"
        "â€¢ ÙˆÛŒØ¯ÛŒÙˆ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ¥\n"
        "â€¢ ÙØ§ÛŒÙ„ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ“„\n"
        "â€¢ ØµØ¯Ø§ Ø¨ÙØ±Ø³ØªÛŒØ¯ ğŸ¤\n\n"
        "Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ú†Ù†Ø¯ÛŒÙ† Ù…ÙˆØ±Ø¯ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.\n"
        "ÙˆÙ‚ØªÛŒ ØªÙ…Ø§Ù… Ø´Ø¯ØŒ Ø¯Ø³ØªÙˆØ± /done Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯."
    )

    return WORK_RESULTS_ENTRY


async def receive_results_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†ØªØ§ÛŒØ¬"""
    message = update.message
    user_data = context.user_data.get('work_data_buffer', [])

    # Ø¯Ø±ÛŒØ§ÙØª Ù…ØªÙ†
    if message.text:
        user_data.append({
            'type': 'text',
            'content': message.text
        })
        await message.reply_text("âœ… Ù…ØªÙ† Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª Ø¹Ú©Ø³
    elif message.photo:
        file_id = message.photo[-1].file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'photo'
        })
        await message.reply_text("âœ… Ø¹Ú©Ø³ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ÙˆÛŒØ¯ÛŒÙˆ
    elif message.video:
        file_id = message.video.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'video'
        })
        await message.reply_text("âœ… ÙˆÛŒØ¯ÛŒÙˆ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ØµØ¯Ø§
    elif message.voice:
        file_id = message.voice.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'voice'
        })
        await message.reply_text("âœ… ØµØ¯Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    # Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„
    elif message.document:
        file_id = message.document.file_id
        user_data.append({
            'type': 'file',
            'file_id': file_id,
            'file_type': 'document'
        })
        await message.reply_text("âœ… ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯ ÛŒØ§ /done Ø¨Ø²Ù†ÛŒØ¯.")

    context.user_data['work_data_buffer'] = user_data
    return WORK_RESULTS_ENTRY


async def finish_results_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù¾Ø§ÛŒØ§Ù† Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ù†ØªØ§ÛŒØ¬"""
    from database.models.user import UserModel

    task_id = context.user_data.get('current_task_id')
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await update.message.reply_text(
            "âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    user_id = user.get('id')
    work_data = context.user_data.get('work_data_buffer', [])

    if not work_data:
        await update.message.reply_text(
            "âŒ Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    # Ø°Ø®ÛŒØ±Ù‡ Ù‡Ø± Ù…ÙˆØ±Ø¯ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    saved_count = 0
    for item in work_data:
        if item['type'] == 'text':
            result = WorkService.add_results(task_id, user_id, text_content=item['content'])
        else:
            result = WorkService.add_results(
                task_id, user_id,
                file_id=item['file_id'],
                file_type=item['file_type']
            )

        if result:
            saved_count += 1

    # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø¨Ø§ÙØ±
    context.user_data.pop('work_data_buffer', None)
    context.user_data.pop('current_task_id', None)

    await update.message.reply_text(
        f"âœ… {saved_count} Ù…ÙˆØ±Ø¯ Ù†ØªÛŒØ¬Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯!",
        reply_markup=get_back_to_tasks_keyboard()
    )

    return ConversationHandler.END


# ==================== Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ø®ÙˆØ¯ ====================

async def start_self_score_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø´Ø±ÙˆØ¹ ÙØ±Ø¢ÛŒÙ†Ø¯ Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯"""
    from database.models.user import UserModel

    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await query.message.reply_text("âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!")
        return ConversationHandler.END

    user_id = user.get('id')

    context.user_data['current_task_id'] = task_id

    # Ù†Ù…Ø§ÛŒØ´ Ø§Ù…ØªÛŒØ§Ø² Ù‚Ø¨Ù„ÛŒ (Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯)
    await display_previous_entries(update, context, task_id, user_id, 'self_score')

    await query.message.reply_text(
        "â­ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ø®ÙˆØ¯\n\n"
        "Ù„Ø·ÙØ§Ù‹ Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø² 1 ØªØ§ 10 ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n\n"
        "Ø¨Ø±Ø§ÛŒ Ù…Ø«Ø§Ù„: 8"
    )

    return WORK_SELF_SCORE_ENTRY


async def receive_self_score(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø²"""
    from database.models.user import UserModel

    message = update.message
    task_id = context.user_data.get('current_task_id')
    telegram_id = update.effective_user.id

    # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
    user = UserModel.get_by_telegram_id(telegram_id)
    if not user:
        await message.reply_text(
            "âŒ Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return ConversationHandler.END

    user_id = user.get('id')

    try:
        score = int(message.text.strip())

        if score < 1 or score > 10:
            await message.reply_text(
                "âŒ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ÛŒ Ø¨ÛŒÙ† 1 ØªØ§ 10 Ø¨Ø§Ø´Ø¯.\n\n"
                "Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:"
            )
            return WORK_SELF_SCORE_ENTRY

        # Ø°Ø®ÛŒØ±Ù‡ Ø§Ù…ØªÛŒØ§Ø² (Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ)
        result = WorkService.set_self_score(task_id, user_id, score)

        if result:
            stars = "â­" * (score // 2)
            await message.reply_text(
                f"âœ… Ø§Ù…ØªÛŒØ§Ø² Ø´Ù…Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯!\n\n"
                f"{stars} {score}/10",
                reply_markup=get_back_to_tasks_keyboard()
            )
        else:
            await message.reply_text(
                "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø²!",
                reply_markup=get_back_to_tasks_keyboard()
            )

        context.user_data.pop('current_task_id', None)
        return ConversationHandler.END

    except ValueError:
        await message.reply_text(
            "âŒ Ù„Ø·ÙØ§Ù‹ ÙÙ‚Ø· Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (1 ØªØ§ 10).\n\n"
            "Ø¨Ø±Ø§ÛŒ Ù…Ø«Ø§Ù„: 7"
        )
        return WORK_SELF_SCORE_ENTRY


# ==================== ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø± ====================

async def submit_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø± - Ù…Ø±Ø­Ù„Ù‡ Ø§ÙˆÙ„: Ù†Ù…Ø§ÛŒØ´ ØªØ£ÛŒÛŒØ¯ÛŒÙ‡"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])
    user_id = update.effective_user.id

    # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…Ú©Ø§Ù† ØªØ­ÙˆÛŒÙ„
    can_submit, message = TaskService.can_employee_submit(task_id, user_id)

    if not can_submit:
        await query.edit_message_text(
            f"âŒ {message}",
            reply_markup=get_back_to_tasks_keyboard()
        )
        return

    # Ù†Ù…Ø§ÛŒØ´ ØªØ£ÛŒÛŒØ¯ÛŒÙ‡
    keyboard = [
        [
            InlineKeyboardButton("âœ… Ø¨Ù„Ù‡ØŒ ØªØ­ÙˆÛŒÙ„ Ø¨Ø¯Ù‡", callback_data=f"confirm_submit_{task_id}"),
            InlineKeyboardButton("âŒ Ø§Ù†ØµØ±Ø§Ù", callback_data=f"work_{task_id}")
        ]
    ]

    await query.edit_message_text(
        "âš ï¸ Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§ÛŒÙ† Ú©Ø§Ø± Ø±Ø§ ØªØ­ÙˆÛŒÙ„ Ø¯Ù‡ÛŒØ¯ØŸ\n\n"
        "Ø¨Ø¹Ø¯ Ø§Ø² ØªØ­ÙˆÛŒÙ„ØŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªØºÛŒÛŒØ±ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯ ØªØ§ Ù…Ø¯ÛŒØ± Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†Ø¯.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def confirm_submit_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø± - Ù…Ø±Ø­Ù„Ù‡ Ø¯ÙˆÙ…: ØªØ£ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒ"""
    query = update.callback_query
    await query.answer()

    task_id = int(query.data.split('_')[-1])

    # ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø±
    success = TaskService.submit_task(task_id)

    if success:
        await query.edit_message_text(
            "âœ… Ú©Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ­ÙˆÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯!\n\n"
            "Ù…Ø¯ÛŒØ± Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ Ù†Ø¸Ø±Ø§Øª Ø®ÙˆØ¯ Ø±Ø§ Ø«Ø¨Øª Ø®ÙˆØ§Ù‡Ø¯ Ú©Ø±Ø¯.",
            reply_markup=get_back_to_tasks_keyboard()
        )
    else:
        await query.edit_message_text(
            "âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø±!",
            reply_markup=get_back_to_tasks_keyboard()
        )


# ==================== Ù„ØºÙˆ ====================

async def cancel_work_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù„ØºÙˆ ÙØ±Ø¢ÛŒÙ†Ø¯ ÙˆØ±ÙˆØ¯ Ø¯Ø§Ø¯Ù‡"""
    context.user_data.pop('work_data_buffer', None)
    context.user_data.pop('current_task_id', None)

    await update.message.reply_text(
        "âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯. Ù‡ÛŒÚ† Ú†ÛŒØ²ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯.",
        reply_markup=get_back_to_tasks_keyboard()
    )

    return ConversationHandler.END


# ==================== ConversationHandler ====================
# ==================== Callback Handlers (Ø®Ø§Ø±Ø¬ Ø§Ø² ConversationHandler) ====================

# Ø¨Ø±Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø±
submit_task_callback = CallbackQueryHandler(submit_task, pattern='^submit_')
confirm_submit_callback = CallbackQueryHandler(confirm_submit_task, pattern='^confirm_submit_')

employee_work_conv_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_knowledge_entry, pattern='^knowledge_'),
        CallbackQueryHandler(start_suggestion_entry, pattern='^suggestion_'),
        CallbackQueryHandler(start_results_entry, pattern='^results_'),
        CallbackQueryHandler(start_self_score_entry, pattern='^self_score_'),
    ],
    states={
        WORK_KNOWLEDGE_ENTRY: [
            MessageHandler(
                (
                            filters.TEXT & ~filters.COMMAND) | filters.PHOTO | filters.VIDEO | filters.VOICE | filters.Document.ALL,
                receive_knowledge_data
            ),
            CommandHandler('done', finish_knowledge_entry),
        ],
        WORK_SUGGESTION_ENTRY: [
            MessageHandler(
                (
                            filters.TEXT & ~filters.COMMAND) | filters.PHOTO | filters.VIDEO | filters.VOICE | filters.Document.ALL,
                receive_suggestion_data
            ),
            CommandHandler('done', finish_suggestion_entry),
        ],
        WORK_RESULTS_ENTRY: [
            MessageHandler(
                (
                            filters.TEXT & ~filters.COMMAND) | filters.PHOTO | filters.VIDEO | filters.VOICE | filters.Document.ALL,
                receive_results_data
            ),
            CommandHandler('done', finish_results_entry),
        ],
        WORK_SELF_SCORE_ENTRY: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, receive_self_score),
        ],
    },
    fallbacks=[
        CommandHandler('cancel', cancel_work_entry),
        MessageHandler(filters.Regex("^ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ$"), cancel_work_entry),
    ],
    per_message=False,
    per_chat=True,
    per_user=True,
    allow_reentry=True
)

<a id='handlers_employee___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 32: handlers\employee\__init__.py
==================================================

# handlers/employee/__init__.py


<a id='main_py'></a>
==================================================
# Ø¨Ø®Ø´ 33: main.py
==================================================

# main.py
import os
import logging
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
)
from handlers.employee.employee_work_handler import (
    employee_work_conv_handler,
    submit_task_callback,
    confirm_submit_callback
)
# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª ØªÙ†Ø¸ÛŒÙ…Ø§Øª
try:
    from config import BOT_TOKEN, ADMIN_ID
except ImportError:
    logging.error("Ø®Ø·Ø§: ÙØ§ÛŒÙ„ config.py Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ ÛŒØ§ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¯Ø± Ø¢Ù† ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯.")
    exit()

# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
from database.migrations.schema import setup_database

# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§
from services.user_service import UserService

# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª utils
from utils.constants import GET_FULL_NAME, GET_PHONE
from utils.keyboards import get_main_menu_keyboard, get_employee_main_keyboard

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù„Ø§Ú¯
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)

# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ - Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ø¯Ù…ÛŒÙ†
from handlers.admin.category_handler import show_categories_menu, category_conv_handler
from handlers.admin.completed_tasks_handler import (
    completed_tasks_conv_handler, show_completed_tasks, show_task_review_panel,
    show_task_profile_for_admin, show_employee_outputs, finalize_task,
    confirm_finalize_task, view_archived_task_for_admin, show_archived_tasks_for_admin,
    show_admin_review_for_archived
)
from handlers.admin.define_task_handler import task_creation_conv_handler
from handlers.admin.edit_task_handler import edit_conv_handler
from handlers.admin.user_management_handler import (
    show_user_management_menu, show_user_details, request_approval_confirmation, confirm_approval
)
from handlers.admin.menu_handler import show_main_menu
from handlers.admin.daily_report_handler import (
    show_daily_report_menu, show_employee_daily_report, show_current_tasks
)
from handlers.admin.new_manage_tasks_handler import (
    show_manage_tasks_new, manage_by_employee, show_employee_tasks_by_category,
    show_tasks_by_employee_category, manage_placeholder
)
from handlers.admin.manage_tasks_handler import (
    show_manage_tasks, list_all_tasks, list_pending_tasks,
    list_in_progress_tasks, list_completed_tasks_manage,
    view_task_details_admin, assign_task_to_employee, change_task_status
)

# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ - Ù†ÛŒØ±ÙˆÙ‡Ø§
from handlers.employee.employee_archive_handler import show_archived_tasks, view_archived_task_details
from handlers.employee.employee_work_handler import (
    show_task_work_panel, start_work_timer, employee_work_conv_handler,
    start_self_score_entry, start_results_entry, start_suggestion_entry,
    start_knowledge_entry, submit_task
)
from handlers.employee.employee_task_handler import (
    list_employee_tasks, view_task_details, back_to_tasks_list, employee_conv_handler
)

# Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ù‡Ù†Ø¯Ù„Ø± Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…
from handlers.registration_handler import registration_conv_handler


# --- ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ---
def get_admin_reply_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† - Ù‡Ù…ÛŒØ´Ù‡ Ø¯Ø± Ø¯Ø³ØªØ±Ø³"""
    keyboard = [
        [KeyboardButton("ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


def get_employee_reply_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ - Ù‡Ù…ÛŒØ´Ù‡ Ø¯Ø± Ø¯Ø³ØªØ±Ø³"""
    keyboard = [
        [KeyboardButton("ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


# --- Ù‡Ù†Ø¯Ù„Ø± Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† Ù…ÙˆØ¬ÙˆØ¯ ---
async def handle_start_for_existing_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù‡Ù†Ø¯Ù„Ø± Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡"""
    user_id = update.effective_user.id
    context.bot_data['admin_id'] = ADMIN_ID
    context.bot_data['bot_token'] = BOT_TOKEN

    # Ú†Ú© Ø§Ø¯Ù…ÛŒÙ†
    if user_id == ADMIN_ID:
        await update.message.reply_text(
            "ğŸ‘‹ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ØŒ Ù…Ø¯ÛŒØ± Ø¹Ø²ÛŒØ²!",
            reply_markup=get_admin_reply_keyboard()
        )
        await update.message.reply_text(
            "ğŸ“‹ Ù…Ù†ÙˆÛŒ Ù…Ø¯ÛŒØ±ÛŒØª:",
            reply_markup=get_main_menu_keyboard()
        )
        return

    # Ú†Ú© Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡
    user = UserService.get_user_info(user_id)
    if user:
        user_id_db, tg_id, first_name, last_name, name, phone_number, role, is_employee, reg_date, approved_date = user

        if is_employee == 1 and role == 'employee':
            await update.message.reply_text(
                f"ğŸ‘‹ Ø³Ù„Ø§Ù… {name} Ø¹Ø²ÛŒØ²!\n\nØ®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯.",
                reply_markup=get_employee_reply_keyboard()
            )
            await update.message.reply_text(
                "ğŸ“‹ Ù…Ù†ÙˆÛŒ Ú©Ø§Ø±ÛŒ Ø´Ù…Ø§:",
                reply_markup=get_employee_main_keyboard()
            )


async def handle_main_menu_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù‡Ù†Ø¯Ù„Ø± Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø«Ø§Ø¨Øª"""
    user_id = update.effective_user.id

    # Ú†Ú© Ø§Ø¯Ù…ÛŒÙ†
    if user_id == ADMIN_ID:
        await update.message.reply_text(
            "ğŸ“‹ Ù…Ù†ÙˆÛŒ Ù…Ø¯ÛŒØ±ÛŒØª:",
            reply_markup=get_main_menu_keyboard()
        )
        return

    # Ú†Ú© Ú©Ø§Ø±Ù…Ù†Ø¯
    user = UserService.get_user_info(user_id)
    if user and user[7] == 1:  # is_employee
        await update.message.reply_text(
            "ğŸ“‹ Ù…Ù†ÙˆÛŒ Ú©Ø§Ø±ÛŒ Ø´Ù…Ø§:",
            reply_markup=get_employee_main_keyboard()
        )


async def back_to_main_menu_employee(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù‡Ù†Ø¯Ù„Ø± Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ù†ÛŒØ±ÙˆÙ‡Ø§"""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:",
        reply_markup=get_employee_main_keyboard()
    )


async def back_to_main_menu_from_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù‡Ù†Ø¯Ù„Ø± Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(
        "ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:",
        reply_markup=get_main_menu_keyboard()
    )


def main() -> None:
    """ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Øª"""
    # Ø­Ø°Ù Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù‚Ø¯ÛŒÙ…ÛŒ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
    db_path = "task_bot.db"
    if os.path.exists(db_path):
        # os.remove(db_path)
        print("ğŸ—‘ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù‚Ø¯ÛŒÙ…ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª.")

    # Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¬Ø¯ÛŒØ¯
    setup_database()

    application = Application.builder().token(BOT_TOKEN).build()

    # ========== ConversationHandler Ù‡Ø§ ==========
    # Ø§Ø¨ØªØ¯Ø§ ConversationHandler Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… (Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¬Ø¯ÛŒØ¯)
    application.add_handler(registration_conv_handler)

    # Ø¨Ù‚ÛŒÙ‡ ConversationHandler Ù‡Ø§
    application.add_handler(task_creation_conv_handler)
    application.add_handler(edit_conv_handler)
    application.add_handler(employee_conv_handler)
    application.add_handler(category_conv_handler)
    application.add_handler(submit_task_callback)
    application.add_handler(confirm_submit_callback)
    application.add_handler(employee_work_conv_handler)
    application.add_handler(completed_tasks_conv_handler)

    # ========== CommandHandler ==========
    # Ù‡Ù†Ø¯Ù„Ø± start Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ùˆ Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† Ù…ÙˆØ¬ÙˆØ¯
    application.add_handler(CommandHandler("start", handle_start_for_existing_users))

    # ========== MessageHandler Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø«Ø§Ø¨Øª ==========
    application.add_handler(MessageHandler(filters.Regex("^ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ$"), handle_main_menu_button))

    # ========== CallbackQueryHandler Ù‡Ø§ ==========

    # --- Ù…Ù†Ùˆ Ùˆ Ù†Ø§ÙˆØ¨Ø±ÛŒ ---
    application.add_handler(CallbackQueryHandler(show_main_menu, pattern='^show_menu$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_from_admin, pattern='^back_to_main_menu$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_employee, pattern='^back_to_main_menu_employee$'))

    # --- Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ ---
    application.add_handler(CallbackQueryHandler(show_daily_report_menu, pattern='^daily_report$'))
    application.add_handler(CallbackQueryHandler(show_employee_daily_report, pattern='^daily_report_'))
    application.add_handler(CallbackQueryHandler(show_current_tasks, pattern='^current_tasks$'))

    # --- Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§ (Ø³ÛŒØ³ØªÙ… Ø¬Ø¯ÛŒØ¯) ---
    application.add_handler(CallbackQueryHandler(show_manage_tasks_new, pattern='^manage_tasks$'))
    application.add_handler(CallbackQueryHandler(manage_by_employee, pattern='^manage_by_employee$'))
    application.add_handler(CallbackQueryHandler(show_employee_tasks_by_category, pattern='^emp_tasks_'))
    application.add_handler(CallbackQueryHandler(show_tasks_by_employee_category, pattern='^emp_cat_'))

    # Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆØ³Ø¹Ù‡
    application.add_handler(CallbackQueryHandler(manage_placeholder, pattern='^manage_by_category$'))
    application.add_handler(CallbackQueryHandler(manage_placeholder, pattern='^manage_by_importance$'))
    application.add_handler(CallbackQueryHandler(manage_placeholder, pattern='^manage_by_priority$'))
    application.add_handler(CallbackQueryHandler(manage_placeholder, pattern='^manage_by_score$'))

    # --- Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§ (Ø³ÛŒØ³ØªÙ… Ù‚Ø¯ÛŒÙ… - Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø²Ú¯Ø§Ø±ÛŒ) ---
    application.add_handler(CallbackQueryHandler(list_all_tasks, pattern='^list_all_tasks$'))
    application.add_handler(CallbackQueryHandler(list_pending_tasks, pattern='^list_pending_tasks$'))
    application.add_handler(CallbackQueryHandler(list_in_progress_tasks, pattern='^list_in_progress_tasks$'))
    application.add_handler(CallbackQueryHandler(list_completed_tasks_manage, pattern='^list_completed_tasks_manage$'))

    # --- Ø¬Ø²Ø¦ÛŒØ§Øª Ùˆ ØªØ®ØµÛŒØµ Ú©Ø§Ø± ---
    application.add_handler(CallbackQueryHandler(view_task_details_admin, pattern='^view_task_'))
    application.add_handler(CallbackQueryHandler(assign_task_to_employee, pattern='^assign_task_'))
    application.add_handler(CallbackQueryHandler(assign_task_to_employee, pattern='^reassign_task_'))
    application.add_handler(CallbackQueryHandler(change_task_status, pattern='^status_'))

    # --- Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§ ---
    application.add_handler(CallbackQueryHandler(show_categories_menu, pattern='^categories$'))

    # --- Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ Ùˆ Ø®Ø§ØªÙ…Ù‡â€ŒÛŒØ§ÙØªÙ‡ ---
    application.add_handler(CallbackQueryHandler(show_completed_tasks, pattern='^completed_tasks$'))
    application.add_handler(CallbackQueryHandler(show_task_review_panel, pattern='^review_task_'))
    application.add_handler(CallbackQueryHandler(show_task_profile_for_admin, pattern='^task_profile_'))
    application.add_handler(CallbackQueryHandler(show_employee_outputs, pattern='^employee_outputs_'))
    application.add_handler(CallbackQueryHandler(finalize_task, pattern='^finalize_task_'))
    application.add_handler(CallbackQueryHandler(confirm_finalize_task, pattern='^confirm_finalize_'))
    application.add_handler(CallbackQueryHandler(show_archived_tasks_for_admin, pattern='^archived_tasks$'))
    application.add_handler(CallbackQueryHandler(view_archived_task_for_admin, pattern='^view_archived_'))
    application.add_handler(CallbackQueryHandler(show_admin_review_for_archived, pattern='^admin_review_archived_'))

    # --- Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ---
    application.add_handler(CallbackQueryHandler(show_user_management_menu, pattern='^user_management$'))
    application.add_handler(CallbackQueryHandler(show_user_details, pattern='^user_'))
    application.add_handler(CallbackQueryHandler(request_approval_confirmation, pattern='^approve_'))
    application.add_handler(CallbackQueryHandler(confirm_approval, pattern='^confirm_approve_'))

    # --- Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ù†ÛŒØ±ÙˆÙ‡Ø§ ---
    application.add_handler(CallbackQueryHandler(list_employee_tasks, pattern='^list_tasks$'))
    application.add_handler(CallbackQueryHandler(view_task_details, pattern='^details_'))
    application.add_handler(CallbackQueryHandler(back_to_tasks_list, pattern='^back_to_tasks_list$'))
    application.add_handler(CallbackQueryHandler(show_task_work_panel, pattern='^work_panel_'))
    application.add_handler(CallbackQueryHandler(show_archived_tasks, pattern='^archive_tasks$'))
    application.add_handler(CallbackQueryHandler(view_archived_task_details, pattern='^view_archive_'))

    # --- Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ú©Ø§Ø± ---
    application.add_handler(CallbackQueryHandler(start_knowledge_entry, pattern='^knowledge_'))
    application.add_handler(CallbackQueryHandler(start_suggestion_entry, pattern='^suggestion_'))
    application.add_handler(CallbackQueryHandler(start_results_entry, pattern='^results_'))
    application.add_handler(CallbackQueryHandler(start_self_score_entry, pattern='^self_score_'))
    application.add_handler(CallbackQueryHandler(start_work_timer, pattern='^start_work_'))
    application.add_handler(CallbackQueryHandler(submit_task, pattern='^submit_'))

    # Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Øª
    print("âœ… Ø¨Ø§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯!")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()

<a id='services_file_service_py'></a>
==================================================
# Ø¨Ø®Ø´ 34: services\file_service.py
==================================================

# services/file_service.py

from database.models.task_attachment import TaskAttachmentModel
from database.models.task_section_file import TaskSectionFileModel
from telegram import Bot
from typing import Optional, List, Dict, Any


class FileService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ - Business Logic"""
    
    @staticmethod
    def add_task_attachment(task_id: int, file_id: str, file_type: str) -> Optional[int]:
        """
        Ø§ÙØ²ÙˆØ¯Ù† ÙØ§ÛŒÙ„ Ø¶Ù…ÛŒÙ…Ù‡ Ø¨Ù‡ Ú©Ø§Ø±
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„ ØªÙ„Ú¯Ø±Ø§Ù…
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            
        Returns:
            attachment_id ÛŒØ§ None
        """
        return TaskAttachmentModel.create(task_id, file_id, file_type)
    
    @staticmethod
    def add_section_file(task_id: int, section_type: str, file_id: str, file_type: str) -> Optional[int]:
        """
        Ø§ÙØ²ÙˆØ¯Ù† ÙØ§ÛŒÙ„ Ø¨Ù‡ Ø¨Ø®Ø´ Ø®Ø§Øµ (results ÛŒØ§ description)
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            section_type: 'results' ÛŒØ§ 'description'
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„ ØªÙ„Ú¯Ø±Ø§Ù…
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            
        Returns:
            file_id ÛŒØ§ None
        """
        return TaskSectionFileModel.create(task_id, section_type, file_id, file_type)
    
    @staticmethod
    def get_task_attachments(task_id: int) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¶Ù…ÛŒÙ…Ù‡ Ú©Ø§Ø±
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            Ù„ÛŒØ³Øª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
        """
        return TaskAttachmentModel.get_by_task(task_id)
    
    @staticmethod
    def get_section_files(task_id: int, section_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            section_type: 'results' ÛŒØ§ 'description' (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
            
        Returns:
            Ù„ÛŒØ³Øª ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
        """
        return TaskSectionFileModel.get_by_task(task_id, section_type)
    
    @staticmethod
    async def send_file_to_user(bot: Bot, chat_id: int, file_id: str, file_type: str, 
                                 caption: Optional[str] = None) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
        
        Args:
            bot: Ù†Ù…ÙˆÙ†Ù‡ Bot
            chat_id: Ø¢ÛŒØ¯ÛŒ Ú†Øª
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„ ØªÙ„Ú¯Ø±Ø§Ù…
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            caption: Ù…ØªÙ† ØªÙˆØ¶ÛŒØ­Ø§Øª (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø§Ø±Ø³Ø§Ù„
        """
        try:
            if file_type == 'photo':
                await bot.send_photo(chat_id=chat_id, photo=file_id, caption=caption)
            elif file_type == 'video':
                await bot.send_video(chat_id=chat_id, video=file_id, caption=caption)
            elif file_type == 'voice':
                await bot.send_voice(chat_id=chat_id, voice=file_id, caption=caption)
            elif file_type == 'document':
                await bot.send_document(chat_id=chat_id, document=file_id, caption=caption)
            else:
                return False
            return True
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„: {e}")
            return False
    
    @staticmethod
    async def send_task_files_to_user(bot: Bot, chat_id: int, task_id: int) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ ØªÙ…Ø§Ù… ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø± Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± (Ø´Ø§Ù…Ù„ attachments Ùˆ section files)
        
        Args:
            bot: Ù†Ù…ÙˆÙ†Ù‡ Bot
            chat_id: Ø¢ÛŒØ¯ÛŒ Ú†Øª
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø§Ø±Ø³Ø§Ù„
        """
        success = True
        
        # Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¶Ù…ÛŒÙ…Ù‡
        attachments = FileService.get_task_attachments(task_id)
        for attachment in attachments:
            result = await FileService.send_file_to_user(
                bot, chat_id, attachment['file_id'], attachment['file_type']
            )
            if not result:
                success = False
        
        return success
    
    @staticmethod
    async def send_section_files_with_labels(bot: Bot, chat_id: int, task_id: int) -> bool:
        """
        Ø§Ø±Ø³Ø§Ù„ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø®Ø´â€ŒÙ‡Ø§ Ø¨Ø§ Ø¨Ø±Ú†Ø³Ø¨ (Ù†ØªØ§ÛŒØ¬ / ØªÙˆØ¶ÛŒØ­Ø§Øª)
        
        Args:
            bot: Ù†Ù…ÙˆÙ†Ù‡ Bot
            chat_id: Ø¢ÛŒØ¯ÛŒ Ú†Øª
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø§Ø±Ø³Ø§Ù„
        """
        success = True
        
        # ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†ØªØ§ÛŒØ¬
        results_files = FileService.get_section_files(task_id, 'results')
        if results_files:
            await bot.send_message(chat_id=chat_id, text="ğŸ“Š ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±:")
            for file_data in results_files:
                result = await FileService.send_file_to_user(
                    bot, chat_id, file_data['file_id'], file_data['file_type']
                )
                if not result:
                    success = False
        
        # ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªÙˆØ¶ÛŒØ­Ø§Øª
        description_files = FileService.get_section_files(task_id, 'description')
        if description_files:
            await bot.send_message(chat_id=chat_id, text="ğŸ“ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªÙˆØ¶ÛŒØ­Ø§Øª:")
            for file_data in description_files:
                result = await FileService.send_file_to_user(
                    bot, chat_id, file_data['file_id'], file_data['file_type']
                )
                if not result:
                    success = False
        
        return success
    
    @staticmethod
    def delete_task_files(task_id: int) -> bool:
        """
        Ø­Ø°Ù ØªÙ…Ø§Ù… ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        success = True
        
        # Ø­Ø°Ù attachments
        if not TaskAttachmentModel.delete_by_task(task_id):
            success = False
        
        # Ø­Ø°Ù section files
        if not TaskSectionFileModel.delete_by_task(task_id):
            success = False
        
        return success
    
    @staticmethod
    def delete_section_files(task_id: int, section_type: str) -> bool:
        """
        Ø­Ø°Ù ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÛŒÚ© Ø¨Ø®Ø´ Ø®Ø§Øµ
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            section_type: 'results' ÛŒØ§ 'description'
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskSectionFileModel.delete_by_task(task_id, section_type)
    
    @staticmethod
    def get_file_type_from_message(message) -> Optional[str]:
        """
        ØªØ´Ø®ÛŒØµ Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ Ø§Ø² Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù…
        
        Args:
            message: Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù…
            
        Returns:
            'photo', 'video', 'voice', 'document' ÛŒØ§ None
        """
        if message.photo:
            return 'photo'
        elif message.video:
            return 'video'
        elif message.voice:
            return 'voice'
        elif message.document:
            return 'document'
        return None
    
    @staticmethod
    def get_file_id_from_message(message) -> Optional[str]:
        """
        Ø§Ø³ØªØ®Ø±Ø§Ø¬ file_id Ø§Ø² Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù…
        
        Args:
            message: Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù…
            
        Returns:
            file_id ÛŒØ§ None
        """
        if message.photo:
            return message.photo[-1].file_id  # Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† Ø³Ø§ÛŒØ²
        elif message.video:
            return message.video.file_id
        elif message.voice:
            return message.voice.file_id
        elif message.document:
            return message.document.file_id
        return None


<a id='services_review_service_py'></a>
==================================================
# Ø¨Ø®Ø´ 35: services\review_service.py
==================================================

# services/review_service.py

from database.models.admin_review import AdminReviewModel
from typing import Optional, List, Dict, Any


class ReviewService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† - Business Logic"""
    
    @staticmethod
    def add_opinion(task_id: int, admin_id: int, text_content: Optional[str] = None,
                    file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ù†Ø¸Ø± Ø§Ø¯Ù…ÛŒÙ†
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            admin_id: Ø¢ÛŒØ¯ÛŒ Ø§Ø¯Ù…ÛŒÙ†
            text_content: Ù…ØªÙ† Ù†Ø¸Ø±
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            
        Returns:
            review_id ÛŒØ§ None
        """
        return AdminReviewModel.create(task_id, admin_id, 'opinion', text_content, file_id, file_type)
    
    @staticmethod
    def add_positive_points(task_id: int, admin_id: int, text_content: Optional[str] = None,
                           file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            admin_id: Ø¢ÛŒØ¯ÛŒ Ø§Ø¯Ù…ÛŒÙ†
            text_content: Ù…ØªÙ† Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            
        Returns:
            review_id ÛŒØ§ None
        """
        return AdminReviewModel.create(task_id, admin_id, 'positive', text_content, file_id, file_type)
    
    @staticmethod
    def add_negative_points(task_id: int, admin_id: int, text_content: Optional[str] = None,
                           file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            admin_id: Ø¢ÛŒØ¯ÛŒ Ø§Ø¯Ù…ÛŒÙ†
            text_content: Ù…ØªÙ† Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            
        Returns:
            review_id ÛŒØ§ None
        """
        return AdminReviewModel.create(task_id, admin_id, 'negative', text_content, file_id, file_type)
    
    @staticmethod
    def add_suggestion(task_id: int, admin_id: int, text_content: Optional[str] = None,
                      file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯/Ø§Ù†ØªÙ‚Ø§Ø¯ Ø§Ø¯Ù…ÛŒÙ†
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            admin_id: Ø¢ÛŒØ¯ÛŒ Ø§Ø¯Ù…ÛŒÙ†
            text_content: Ù…ØªÙ† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
            
        Returns:
            review_id ÛŒØ§ None
        """
        return AdminReviewModel.create(task_id, admin_id, 'suggestion', text_content, file_id, file_type)
    
    @staticmethod
    def add_score(task_id: int, admin_id: int, admin_score: int,
                  text_content: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ø§Ù…ØªÛŒØ§Ø² Ø§Ø¯Ù…ÛŒÙ†
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            admin_id: Ø¢ÛŒØ¯ÛŒ Ø§Ø¯Ù…ÛŒÙ†
            admin_score: Ø§Ù…ØªÛŒØ§Ø² (1-10)
            text_content: ØªÙˆØ¶ÛŒØ­Ø§Øª Ø§Ø®ØªÛŒØ§Ø±ÛŒ
            
        Returns:
            review_id ÛŒØ§ None
        """
        return AdminReviewModel.create(task_id, admin_id, 'score', text_content, 
                                      admin_score=admin_score)
    
    @staticmethod
    def get_all_reviews(task_id: int) -> Dict[str, List[Dict[str, Any]]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            dict Ø¨Ø§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ 'opinion', 'positive', 'negative', 'suggestion', 'score'
        """
        return {
            'opinion': AdminReviewModel.get_by_task(task_id, 'opinion'),
            'positive': AdminReviewModel.get_by_task(task_id, 'positive'),
            'negative': AdminReviewModel.get_by_task(task_id, 'negative'),
            'suggestion': AdminReviewModel.get_by_task(task_id, 'suggestion'),
            'score': AdminReviewModel.get_by_task(task_id, 'score')
        }
    
    @staticmethod
    def get_opinions(task_id: int) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†"""
        return AdminReviewModel.get_by_task(task_id, 'opinion')
    
    @staticmethod
    def get_positive_points(task_id: int) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª"""
        return AdminReviewModel.get_by_task(task_id, 'positive')
    
    @staticmethod
    def get_negative_points(task_id: int) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ"""
        return AdminReviewModel.get_by_task(task_id, 'negative')
    
    @staticmethod
    def get_suggestions(task_id: int) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ø§Ø¯Ù…ÛŒÙ†"""
        return AdminReviewModel.get_by_task(task_id, 'suggestion')
    
    @staticmethod
    def get_scores(task_id: int) -> List[Dict[str, Any]]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ø«Ø¨Øª Ø´Ø¯Ù‡"""
        return AdminReviewModel.get_by_task(task_id, 'score')
    
    @staticmethod
    def get_latest_score(task_id: int) -> Optional[int]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø®Ø±ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø² Ø§Ø¯Ù…ÛŒÙ†
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            Ø§Ù…ØªÛŒØ§Ø² ÛŒØ§ None
        """
        return AdminReviewModel.get_latest_score(task_id)
    
    @staticmethod
    def format_reviews_for_display(reviews: List[Dict[str, Any]], review_type: str) -> str:
        """
        ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ù†Ø¸Ø±Ø§Øª Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´
        
        Args:
            reviews: Ù„ÛŒØ³Øª Ù†Ø¸Ø±Ø§Øª
            review_type: Ù†ÙˆØ¹ Ù†Ø¸Ø±
            
        Returns:
            str: Ù…ØªÙ† ÙØ±Ù…Øª Ø´Ø¯Ù‡
        """
        type_emoji = {
            'opinion': 'ğŸ’­',
            'positive': 'âœ…',
            'negative': 'âŒ',
            'suggestion': 'ğŸ’¡',
            'score': 'â­'
        }
        
        type_title = {
            'opinion': 'Ù†Ø¸Ø± Ø´Ù…Ø§',
            'positive': 'Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª',
            'negative': 'Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ',
            'suggestion': 'Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯/Ø§Ù†ØªÙ‚Ø§Ø¯',
            'score': 'Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ'
        }
        
        if not reviews:
            return f"{type_emoji.get(review_type, 'ğŸ“')} Ù‡ÛŒÚ† {type_title.get(review_type, 'Ù†Ø¸Ø±ÛŒ')} Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
        
        text = f"{type_emoji.get(review_type, 'ğŸ“')} {type_title.get(review_type, 'Ù†Ø¸Ø±Ø§Øª')}:\n\n"
        
        for idx, review in enumerate(reviews, 1):
            text += f"#{idx} - {review.get('timestamp', 'Ø¨Ø¯ÙˆÙ† ØªØ§Ø±ÛŒØ®')}\n"
            
            if review.get('text_content'):
                text += f"{review['text_content']}\n"
            
            if review.get('admin_score'):
                text += f"Ø§Ù…ØªÛŒØ§Ø²: {review['admin_score']}/10\n"
            
            if review.get('file_id'):
                file_type_text = {
                    'photo': 'ğŸ–¼ ØªØµÙˆÛŒØ±',
                    'video': 'ğŸ¥ ÙˆÛŒØ¯ÛŒÙˆ',
                    'voice': 'ğŸ¤ ØµØ¯Ø§',
                    'document': 'ğŸ“„ ÙØ§ÛŒÙ„'
                }
                text += f"{file_type_text.get(review.get('file_type'), 'ğŸ“ ÙØ§ÛŒÙ„')} Ø¶Ù…ÛŒÙ…Ù‡ Ø´Ø¯Ù‡\n"
            
            text += "\n"
        
        return text
    
    @staticmethod
    def has_any_review(task_id: int) -> bool:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø§Ø¯Ù…ÛŒÙ† Ù‡ÛŒÚ† Ù†Ø¸Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø± Ø«Ø¨Øª Ú©Ø±Ø¯Ù‡ ÛŒØ§ Ù†Ù‡
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            bool: Ø¢ÛŒØ§ Ù†Ø¸Ø±ÛŒ Ø«Ø¨Øª Ø´Ø¯Ù‡ØŸ
        """
        all_reviews = ReviewService.get_all_reviews(task_id)
        return any(len(reviews) > 0 for reviews in all_reviews.values())
    
    @staticmethod
    def get_review_summary(task_id: int) -> str:
        """
        Ø®Ù„Ø§ØµÙ‡â€ŒØ§ÛŒ Ø§Ø² Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            str: Ø®Ù„Ø§ØµÙ‡ Ù†Ø¸Ø±Ø§Øª
        """
        all_reviews = ReviewService.get_all_reviews(task_id)
        
        opinion_count = len(all_reviews['opinion'])
        positive_count = len(all_reviews['positive'])
        negative_count = len(all_reviews['negative'])
        suggestion_count = len(all_reviews['suggestion'])
        
        latest_score = ReviewService.get_latest_score(task_id)
        
        summary = "ğŸ“Š Ø®Ù„Ø§ØµÙ‡ Ù†Ø¸Ø±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†:\n\n"
        summary += f"ğŸ’­ Ù†Ø¸Ø±Ø§Øª: {opinion_count}\n"
        summary += f"âœ… Ù†Ù‚Ø§Ø· Ù…Ø«Ø¨Øª: {positive_count}\n"
        summary += f"âŒ Ù†Ù‚Ø§Ø· Ù…Ù†ÙÛŒ: {negative_count}\n"
        summary += f"ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª: {suggestion_count}\n"
        
        if latest_score:
            summary += f"â­ Ø¢Ø®Ø±ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø²: {latest_score}/10\n"
        else:
            summary += "â­ Ø§Ù…ØªÛŒØ§Ø²: Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡\n"
        
        return summary
    
    @staticmethod
    def delete_task_reviews(task_id: int) -> bool:
        """
        Ø­Ø°Ù ØªÙ…Ø§Ù… Ù†Ø¸Ø±Ø§Øª ÛŒÚ© Ú©Ø§Ø±
        
        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            
        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return AdminReviewModel.delete_by_task(task_id)


<a id='services_task_service_py'></a>
==================================================
# Ø¨Ø®Ø´ 36: services\task_service.py
==================================================

# services/task_service.py

from database.models.task import TaskModel
from database.models.category import CategoryModel
from typing import Optional, List, Dict, Any


class TaskService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§ - Business Logic"""

    @staticmethod
    def create_task(task_data: Dict[str, Any]) -> Optional[int]:
        """
        Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø± Ø¬Ø¯ÛŒØ¯

        Args:
            task_data: Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ø­Ø§ÙˆÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±

        Returns:
            task_id ÛŒØ§ None
        """
        return TaskModel.create(**task_data)

    @staticmethod
    def get_categories() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§

        Returns:
            Ù„ÛŒØ³Øª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§
        """
        return CategoryModel.get_all()

    @staticmethod
    def get_task(task_id: int, with_details: bool = False) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            with_details: Ø¢ÛŒØ§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ù…Ù„ (Ø¨Ø§ join) Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ø´ÙˆØ¯ØŸ

        Returns:
            dict Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø± ÛŒØ§ None
        """
        if with_details:
            return TaskModel.get_with_details(task_id)
        return TaskModel.get_by_id(task_id)

    @staticmethod
    def get_employee_tasks(employee_id: int, status: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯

        Args:
            employee_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
            status: ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±Ù‡Ø§ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

        Returns:
            Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§
        """
        return TaskModel.get_by_employee(employee_id, status)

    @staticmethod
    def get_tasks_by_status(status: str) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ Ø¨Ø§ ÙˆØ¶Ø¹ÛŒØª Ø®Ø§Øµ

        Args:
            status: ÙˆØ¶Ø¹ÛŒØª ('pending', 'in_progress', 'completed', 'archived')

        Returns:
            Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§
        """
        return TaskModel.get_by_status(status)

    @staticmethod
    def get_completed_submitted_tasks() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡

        Returns:
            Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ Ú©Ù‡ Ù‡Ù†ÙˆØ² finalize Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯
        """
        return TaskModel.get_completed_submitted()

    @staticmethod
    def get_archived_tasks() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡

        Returns:
            Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ø±Ø´ÛŒÙˆ
        """
        return TaskModel.get_archived()

    @staticmethod
    def update_task_status(task_id: int, status: str) -> bool:
        """
        Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            status: ÙˆØ¶Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskModel.update_status(task_id, status)

    @staticmethod
    def submit_task(task_id: int) -> bool:
        """
        ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø± ØªÙˆØ³Ø· Ú©Ø§Ø±Ù…Ù†Ø¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskModel.mark_as_submitted(task_id)

    @staticmethod
    def finalize_task(task_id: int) -> bool:
        """
        Ø®Ø§ØªÙ…Ù‡ Ú©Ø§Ø± ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskModel.mark_as_finalized(task_id)

    @staticmethod
    def update_task(task_id: int, **kwargs) -> bool:
        """
        Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            **kwargs: ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskModel.update(task_id, **kwargs)

    @staticmethod
    def delete_task(task_id: int) -> bool:
        """
        Ø­Ø°Ù Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskModel.delete(task_id)

    @staticmethod
    def assign_task_to_employee(task_id: int, employee_id: int) -> bool:
        """
        ØªØ®ØµÛŒØµ Ú©Ø§Ø± Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            employee_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return TaskModel.update(task_id, assigned_to_id=employee_id)

    @staticmethod
    def format_task_profile(task: Dict[str, Any], include_employee: bool = True) -> str:
        """
        ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø±

        Args:
            task: dict Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
            include_employee: Ø¢ÛŒØ§ Ù†Ø§Ù… Ú©Ø§Ø±Ù…Ù†Ø¯ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆØ¯ØŸ

        Returns:
            str: Ù…ØªÙ† ÙØ±Ù…Øª Ø´Ø¯Ù‡
        """
        text = f"ğŸ“‹ Ø´Ù†Ø§Ø³Ù†Ø§Ù…Ù‡ Ú©Ø§Ø±\n\n"
        text += f"Ø¹Ù†ÙˆØ§Ù†: {task.get('title', 'Ù†Ø¯Ø§Ø±Ø¯')}\n"

        if include_employee and task.get('assigned_to_name'):
            text += f"Ú©Ø§Ø±Ù…Ù†Ø¯: {task.get('assigned_to_name')}\n"

        if task.get('category_name'):
            text += f"Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {task.get('category_name')}\n"

        if task.get('duration'):
            text += f"Ù…Ø¯Øª Ø²Ù…Ø§Ù†: {task.get('duration')} Ø¯Ù‚ÛŒÙ‚Ù‡\n"

        if task.get('results'):
            text += f"Ù†ØªØ§ÛŒØ¬ Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: {task.get('results')}\n"

        if task.get('description'):
            text += f"ØªÙˆØ¶ÛŒØ­Ø§Øª: {task.get('description')}\n"

        if task.get('importance'):
            text += f"Ø§Ù‡Ù…ÛŒØª: {task.get('importance')}\n"

        if task.get('priority'):
            text += f"Ø§ÙˆÙ„ÙˆÛŒØª: {task.get('priority')}\n"

        if task.get('creation_date'):
            text += f"ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯: {task.get('creation_date')}\n"

        if task.get('completion_date'):
            text += f"ØªØ§Ø±ÛŒØ® ØªØ­ÙˆÛŒÙ„: {task.get('completion_date')}\n"

        # ÙˆØ¶Ø¹ÛŒØª
        status_text = {
            'pending': 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±',
            'in_progress': 'ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…',
            'completed': 'âœ… ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡',
            'on_hold': 'â¸ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡',
            'archived': 'ğŸ—„ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡'
        }
        text += f"ÙˆØ¶Ø¹ÛŒØª: {status_text.get(task.get('status'), 'Ù†Ø§Ù…Ø´Ø®Øµ')}\n"

        return text

    @staticmethod
    def format_task_list_item(task: Dict[str, Any]) -> str:
        """
        ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ÛŒÚ© Ø¢ÛŒØªÙ… Ø¯Ø± Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§

        Args:
            task: dict Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±

        Returns:
            str: Ù…ØªÙ† ÙØ±Ù…Øª Ø´Ø¯Ù‡
        """
        title = task.get('title', 'Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†')
        employee = task.get('employee_name', task.get('assigned_to_name', ''))

        if employee:
            return f"{title} ({employee})"
        return title

    @staticmethod
    @staticmethod
    @staticmethod
    @staticmethod
    def can_employee_submit(task_id: int, telegram_id: int) -> tuple[bool, str]:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ø§Ø±Ù…Ù†Ø¯ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ø§Ø± Ø±Ø§ ØªØ­ÙˆÛŒÙ„ Ø¯Ù‡Ø¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            telegram_id: ØªÙ„Ú¯Ø±Ø§Ù… Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯

        Returns:
            tuple: (Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ØªØ­ÙˆÛŒÙ„ Ø¯Ù‡Ø¯, Ù¾ÛŒØ§Ù…)
        """
        from database.models.user import UserModel
        from services.work_service import WorkService

        task = TaskModel.get_by_id(task_id)

        if not task:
            return False, "Ú©Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!"

        # ØªØ¨Ø¯ÛŒÙ„ telegram_id Ø¨Ù‡ user.id
        user = UserModel.get_by_telegram_id(telegram_id)
        if not user:
            return False, "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!"

        user_id = user.get('id')

        # Ø¯ÛŒØ¨Ø§Ú¯
        print(f"ğŸ” DEBUG: task_id={task_id}, telegram_id={telegram_id}, user_id={user_id}")

        if task.get('assigned_to_id') != user_id:
            return False, "Ø§ÛŒÙ† Ú©Ø§Ø± Ø¨Ù‡ Ø´Ù…Ø§ ØªØ®ØµÛŒØµ Ø¯Ø§Ø¯Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª!"

        if task.get('status') == 'completed':
            return False, "Ø§ÛŒÙ† Ú©Ø§Ø± Ù‚Ø¨Ù„Ø§Ù‹ ØªØ­ÙˆÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª!"

        if task.get('status') == 'archived':
            return False, "Ø§ÛŒÙ† Ú©Ø§Ø± Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡ Ø§Ø³Øª!"

        # Ú†Ú© Ú©Ø±Ø¯Ù† Ù†ØªØ§ÛŒØ¬
        results = WorkService.get_task_results(task_id, user_id)
        print(f"ğŸ” DEBUG: ØªØ¹Ø¯Ø§Ø¯ Ù†ØªØ§ÛŒØ¬ = {len(results)}")
        print(f"ğŸ” DEBUG: Ù†ØªØ§ÛŒØ¬ = {results}")

        if not results or len(results) == 0:
            return False, "Ø¨Ø±Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø± Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ù†ØªÛŒØ¬Ù‡ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯!"

        # Ú†Ú© Ú©Ø±Ø¯Ù† Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯
        self_score = WorkService.get_self_score(task_id, user_id)
        print(f"ğŸ” DEBUG: Ø§Ù…ØªÛŒØ§Ø² = {self_score}")

        if not self_score:
            return False, "Ø¨Ø±Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø± Ø¨Ø§ÛŒØ¯ Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ø±Ø§ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯!"

        return True, "Ø§Ù…Ú©Ø§Ù† ØªØ­ÙˆÛŒÙ„ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"

    @staticmethod
    def can_admin_finalize(task_id: int) -> tuple[bool, str]:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ø§Ø± Ø±Ø§ Ø®Ø§ØªÙ…Ù‡ Ø¯Ù‡Ø¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            tuple: (Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§ØªÙ…Ù‡ Ø¯Ù‡Ø¯, Ù¾ÛŒØ§Ù…)
        """
        task = TaskModel.get_by_id(task_id)

        if not task:
            return False, "Ú©Ø§Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯!"

        if task.get('status') != 'completed':
            return False, "ÙÙ‚Ø· Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡ Ù‚Ø§Ø¨Ù„ Ø®Ø§ØªÙ…Ù‡ Ù‡Ø³ØªÙ†Ø¯!"

        if not task.get('is_submitted'):
            return False, "Ú©Ø§Ø± Ù‡Ù†ÙˆØ² ØªÙˆØ³Ø· Ú©Ø§Ø±Ù…Ù†Ø¯ ØªØ­ÙˆÛŒÙ„ Ø¯Ø§Ø¯Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª!"

        if task.get('is_finalized'):
            return False, "Ø§ÛŒÙ† Ú©Ø§Ø± Ù‚Ø¨Ù„Ø§Ù‹ Ø®Ø§ØªÙ…Ù‡ ÛŒØ§ÙØªÙ‡ Ø§Ø³Øª!"

        return True, "Ø§Ù…Ú©Ø§Ù† Ø®Ø§ØªÙ…Ù‡ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯"

    @staticmethod
    def get_tasks_for_admin_review() -> List[tuple]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ†

        Returns:
            Ù„ÛŒØ³Øª Ø§Ø² tuple: (task_id, title, employee_name, completion_date)
        """
        tasks = TaskModel.get_completed_submitted()

        result = []
        for task in tasks:
            result.append((
                task.get('id'),
                task.get('title'),
                task.get('employee_name', 'Ø¨Ø¯ÙˆÙ† Ù†Ø§Ù…'),
                task.get('completion_date', 'Ù†Ø§Ù…Ø´Ø®Øµ')
            ))

        return result

    @staticmethod
    def get_task_review_info(task_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ†

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            dict Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±
        """
        return TaskModel.get_with_details(task_id)

<a id='services_user_service_py'></a>
==================================================
# Ø¨Ø®Ø´ 37: services\user_service.py
==================================================

# services/user_service.py

from database.models.user import UserModel
from typing import Optional, List, Dict, Any


class UserService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† - Business Logic"""

    @staticmethod
    def register_user(telegram_id: int, first_name: str, last_name: str,
                      phone_number: Optional[str] = None) -> bool:
        """
        Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯

        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
            first_name: Ù†Ø§Ù…
            last_name: Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ
            phone_number: Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return UserModel.create(telegram_id, first_name, last_name, phone_number)

    @staticmethod
    def get_user_info(telegram_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±

        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…

        Returns:
            dict Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ None
        """
        return UserModel.get_by_telegram_id(telegram_id)

    @staticmethod
    def get_user_by_id(user_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ database id

        Args:
            user_id: Ø¢ÛŒØ¯ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³

        Returns:
            dict Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ None
        """
        return UserModel.get_by_id(user_id)

    @staticmethod
    def get_pending_users() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯

        Returns:
            Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† pending
        """
        return UserModel.get_all_pending()

    @staticmethod
    def get_all_employees() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡

        Returns:
            Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù†
        """
        return UserModel.get_all_employees()

    @staticmethod
    def get_all_users() -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù†

        Returns:
            Ù„ÛŒØ³Øª ØªÙ…Ø§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
        """
        return UserModel.get_all()

    @staticmethod
    def approve_employee(telegram_id: int) -> bool:
        """
        ØªØ£ÛŒÛŒØ¯ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ú©Ø§Ø±Ù…Ù†Ø¯

        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        return UserModel.approve_as_employee(telegram_id)

    @staticmethod
    def is_admin(telegram_id: int) -> bool:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø¨ÙˆØ¯Ù†

        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…

        Returns:
            bool: Ø§Ø¯Ù…ÛŒÙ† Ø§Ø³Øª ÛŒØ§ Ù†Ù‡
        """
        return UserModel.is_admin(telegram_id)

    @staticmethod
    def is_employee(telegram_id: int) -> bool:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ Ø¨ÙˆØ¯Ù†

        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…

        Returns:
            bool: Ú©Ø§Ø±Ù…Ù†Ø¯ Ø§Ø³Øª ÛŒØ§ Ù†Ù‡
        """
        return UserModel.is_employee(telegram_id)

    @staticmethod
    def get_user_role(telegram_id: int) -> Optional[str]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ù†Ù‚Ø´ Ú©Ø§Ø±Ø¨Ø±

        Args:
            telegram_id: Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…

        Returns:
            'admin', 'employee', 'pending' ÛŒØ§ None
        """
        user = UserModel.get_by_telegram_id(telegram_id)
        if user:
            return user.get('role')
        return None

    @staticmethod
    def format_user_details(user: Dict[str, Any]) -> str:
        """
        ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´

        Args:
            user: dict Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±

        Returns:
            str: Ù…ØªÙ† ÙØ±Ù…Øª Ø´Ø¯Ù‡
        """
        role_text = {
            'admin': 'ğŸ‘¨â€ğŸ’¼ Ù…Ø¯ÛŒØ±',
            'employee': 'ğŸ‘· Ú©Ø§Ø±Ù…Ù†Ø¯',
            'pending': 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯'
        }

        text = (
            f"ğŸ‘¤ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±\n\n"
            f"Ù†Ø§Ù…: {user.get('name', 'Ù†Ø¯Ø§Ø±Ø¯')}\n"
            f"Ù†Ù‚Ø´: {role_text.get(user.get('role'), 'Ù†Ø§Ù…Ø´Ø®Øµ')}\n"
            f"ØªØ§Ø±ÛŒØ® Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…: {user.get('registration_date', 'Ù†Ø¯Ø§Ø±Ø¯')}\n"
        )

        if user.get('approved_date'):
            text += f"ØªØ§Ø±ÛŒØ® ØªØ£ÛŒÛŒØ¯: {user.get('approved_date')}\n"

        if user.get('phone_number'):
            text += f"Ø´Ù…Ø§Ø±Ù‡ ØªÙ…Ø§Ø³: {user.get('phone_number')}\n"

        return text

<a id='services_work_service_py'></a>
==================================================
# Ø¨Ø®Ø´ 38: services\work_service.py
==================================================

# services/work_service.py

from database.models.task_work_data import TaskWorkDataModel
from database.models.task_scores import TaskScoresModel
from typing import Optional, List, Dict, Any


class WorkService:
    """Ø³Ø±ÙˆÛŒØ³ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø«Ø¨Øª Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ú©Ø§Ø±Ù…Ù†Ø¯Ø§Ù† - Business Logic"""

    @staticmethod
    def add_knowledge(task_id: int, user_id: int, text_content: Optional[str] = None,
                      file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ø¯Ø§Ù†Ø´ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
            text_content: Ù…ØªÙ† Ø¯Ø§Ù†Ø´
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„

        Returns:
            data_id ÛŒØ§ None
        """
        return TaskWorkDataModel.create(task_id, user_id, 'knowledge', text_content, file_id, file_type)

    @staticmethod
    def add_suggestion(task_id: int, user_id: int, text_content: Optional[str] = None,
                       file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
            text_content: Ù…ØªÙ† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„

        Returns:
            data_id ÛŒØ§ None
        """
        return TaskWorkDataModel.create(task_id, user_id, 'suggestion', text_content, file_id, file_type)

    @staticmethod
    def add_results(task_id: int, user_id: int, text_content: Optional[str] = None,
                    file_id: Optional[str] = None, file_type: Optional[str] = None) -> Optional[int]:
        """
        Ø«Ø¨Øª Ù†ØªØ§ÛŒØ¬ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
            text_content: Ù…ØªÙ† Ù†ØªØ§ÛŒØ¬
            file_id: Ø¢ÛŒØ¯ÛŒ ÙØ§ÛŒÙ„
            file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„

        Returns:
            data_id ÛŒØ§ None
        """
        return TaskWorkDataModel.create(task_id, user_id, 'results', text_content, file_id, file_type)

    @staticmethod
    def set_self_score(task_id: int, user_id: int, score: int) -> Optional[int]:
        """
        Ø«Ø¨Øª ÛŒØ§ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯
            score: Ø§Ù…ØªÛŒØ§Ø² (1-10)

        Returns:
            score_id ÛŒØ§ None
        """
        return TaskScoresModel.create_or_update(task_id, user_id, score)

    @staticmethod
    def get_self_score(task_id: int, user_id: int) -> Optional[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ú©Ø§Ø±Ù…Ù†Ø¯

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯

        Returns:
            dict Ø§Ù…ØªÛŒØ§Ø² ÛŒØ§ None
        """
        return TaskScoresModel.get_by_task_and_user(task_id, user_id)

    @staticmethod
    def get_task_knowledge(task_id: int, user_id: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ø¯Ø§Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

        Returns:
            Ù„ÛŒØ³Øª Ø¯Ø§Ù†Ø´â€ŒÙ‡Ø§
        """
        if user_id:
            return TaskWorkDataModel.get_by_task_and_user(task_id, user_id, 'knowledge')
        return TaskWorkDataModel.get_by_task(task_id, 'knowledge')

    @staticmethod
    def get_task_suggestions(task_id: int, user_id: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ÛŒ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

        Returns:
            Ù„ÛŒØ³Øª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§
        """
        if user_id:
            return TaskWorkDataModel.get_by_task_and_user(task_id, user_id, 'suggestion')
        return TaskWorkDataModel.get_by_task(task_id, 'suggestion')

    @staticmethod
    def get_task_results(task_id: int, user_id: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ù†ØªØ§ÛŒØ¬ Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)

        Returns:
            Ù„ÛŒØ³Øª Ù†ØªØ§ÛŒØ¬
        """
        if user_id:
            return TaskWorkDataModel.get_by_task_and_user(task_id, user_id, 'results')
        return TaskWorkDataModel.get_by_task(task_id, 'results')

    @staticmethod
    def get_all_work_data(task_id: int) -> Dict[str, List[Dict[str, Any]]]:
        """
        Ø¯Ø±ÛŒØ§ÙØª ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ (Ø¯Ø§Ù†Ø´ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ØŒ Ù†ØªØ§ÛŒØ¬) Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            dict Ø¨Ø§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ 'knowledge', 'suggestion', 'results'
        """
        return {
            'knowledge': WorkService.get_task_knowledge(task_id),
            'suggestion': WorkService.get_task_suggestions(task_id),
            'results': WorkService.get_task_results(task_id)
        }

    @staticmethod
    def get_employee_work_data(task_id: int, user_id: int) -> Dict[str, Any]:
        """
        Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ ÛŒÚ© Ú©Ø§Ø±Ù…Ù†Ø¯ Ø®Ø§Øµ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ú©Ø§Ø±

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯

        Returns:
            dict Ø¨Ø§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ 'knowledge', 'suggestion', 'results', 'self_score'
        """
        return {
            'knowledge': TaskWorkDataModel.get_by_task_and_user(task_id, user_id, 'knowledge'),
            'suggestion': TaskWorkDataModel.get_by_task_and_user(task_id, user_id, 'suggestion'),
            'results': TaskWorkDataModel.get_by_task_and_user(task_id, user_id, 'results'),
            'self_score': TaskScoresModel.get_by_task_and_user(task_id, user_id)
        }

    @staticmethod
    def format_work_data_for_display(work_data: List[Dict[str, Any]], data_type: str) -> str:
        """
        ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´

        Args:
            work_data: Ù„ÛŒØ³Øª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ
            data_type: Ù†ÙˆØ¹ Ø¯Ø§Ø¯Ù‡ ('knowledge', 'suggestion', 'results')

        Returns:
            str: Ù…ØªÙ† ÙØ±Ù…Øª Ø´Ø¯Ù‡
        """
        type_emoji = {
            'knowledge': 'ğŸ“š',
            'suggestion': 'ğŸ’¡',
            'results': 'ğŸ“Š'
        }

        type_title = {
            'knowledge': 'Ø¯Ø§Ù†Ø´',
            'suggestion': 'Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯',
            'results': 'Ù†ØªØ§ÛŒØ¬'
        }

        if not work_data:
            return f"{type_emoji.get(data_type, 'ğŸ“')} Ù‡ÛŒÚ† {type_title.get(data_type, 'Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ')} Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."

        text = f"{type_emoji.get(data_type, 'ğŸ“')} {type_title.get(data_type, 'Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§')} Ø«Ø¨Øª Ø´Ø¯Ù‡:\n\n"

        for idx, item in enumerate(work_data, 1):
            text += f"#{idx} - {item.get('timestamp', 'Ø¨Ø¯ÙˆÙ† ØªØ§Ø±ÛŒØ®')}\n"

            if item.get('text_content'):
                text += f"{item['text_content']}\n"

            if item.get('file_id'):
                file_type_text = {
                    'photo': 'ğŸ–¼ ØªØµÙˆÛŒØ±',
                    'video': 'ğŸ¥ ÙˆÛŒØ¯ÛŒÙˆ',
                    'voice': 'ğŸ¤ ØµØ¯Ø§',
                    'document': 'ğŸ“„ ÙØ§ÛŒÙ„'
                }
                text += f"{file_type_text.get(item.get('file_type'), 'ğŸ“ ÙØ§ÛŒÙ„')} Ø¶Ù…ÛŒÙ…Ù‡ Ø´Ø¯Ù‡\n"

            text += "\n"

        return text

    @staticmethod
    def format_self_score_for_display(score_data: Optional[Dict[str, Any]]) -> str:
        """
        ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´

        Args:
            score_data: dict Ø§Ù…ØªÛŒØ§Ø²

        Returns:
            str: Ù…ØªÙ† ÙØ±Ù…Øª Ø´Ø¯Ù‡
        """
        if not score_data:
            return "â­ Ù‡ÛŒÚ† Ø§Ù…ØªÛŒØ§Ø²ÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."

        score = score_data.get('self_score', 0)
        timestamp = score_data.get('timestamp', 'Ø¨Ø¯ÙˆÙ† ØªØ§Ø±ÛŒØ®')

        # ØªØ¨Ø¯ÛŒÙ„ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ø³ØªØ§Ø±Ù‡
        stars = "â­" * (score // 2) if score > 0 else ""

        text = f"â­ Ø§Ù…ØªÛŒØ§Ø² Ø®ÙˆØ¯:\n\n"
        text += f"Ø§Ù…ØªÛŒØ§Ø²: {stars} {score}/10\n"
        text += f"ØªØ§Ø±ÛŒØ®: {timestamp}\n"

        return text

    @staticmethod
    def has_any_work_data(task_id: int, user_id: int) -> bool:
        """
        Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ø§Ø±Ù…Ù†Ø¯ Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø± Ø«Ø¨Øª Ú©Ø±Ø¯Ù‡ ÛŒØ§ Ù†Ù‡

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
            user_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯

        Returns:
            bool: Ø¢ÛŒØ§ Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø«Ø¨Øª Ø´Ø¯Ù‡ØŸ
        """
        data = WorkService.get_employee_work_data(task_id, user_id)

        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ù†Ø´ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ØŒ Ù†ØªØ§ÛŒØ¬
        has_work = any(len(data.get(key, [])) > 0 for key in ['knowledge', 'suggestion', 'results'])

        # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…ØªÛŒØ§Ø²
        has_score = data.get('self_score') is not None

        return has_work or has_score

    @staticmethod
    def delete_task_work_data(task_id: int) -> bool:
        """
        Ø­Ø°Ù ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ ÛŒÚ© Ú©Ø§Ø± (Ø¯Ø§Ù†Ø´ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ØŒ Ù†ØªØ§ÛŒØ¬ØŒ Ø§Ù…ØªÛŒØ§Ø²)

        Args:
            task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±

        Returns:
            bool: Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª
        """
        # Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±ÛŒ
        work_deleted = TaskWorkDataModel.delete_by_task(task_id)

        # Ø­Ø°Ù Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§
        scores_deleted = TaskScoresModel.delete_by_task(task_id)

        return work_deleted and scores_deleted

<a id='services___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 39: services\__init__.py
==================================================

# services/__init__.py

from services.user_service import UserService
from services.task_service import TaskService
from services.file_service import FileService
from services.work_service import WorkService
from services.review_service import ReviewService

__all__ = [
    'UserService',
    'TaskService',
    'FileService',
    'WorkService',
    'ReviewService'
]


<a id='utils_constants_py'></a>
==================================================
# Ø¨Ø®Ø´ 40: utils\constants.py
==================================================

# utils/constants.py

"""
ØªÙ…Ø§Ù… States Ùˆ Constants Ù…ÙˆØ±Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ù¾Ø±ÙˆÚ˜Ù‡
"""

# ==================== Registration States ====================
GET_FULL_NAME, GET_PHONE = range(2)

# ==================== Employee Task States ====================
(
    TASK_START_CONFIRMATION,
    TASK_WORK_VIEW
) = range(10, 12)

# ==================== Category States ====================
GET_CATEGORY_NAME = 30

# ==================== User Management States ====================
AWAITING_CONFIRMATION = 40

# ==================== Work States (Employee) - Old ====================
(
    WORK_KNOWLEDGE_TEXT, WORK_KNOWLEDGE_FILE,
    WORK_SUGGESTION_TEXT, WORK_SUGGESTION_FILE,
    WORK_RESULTS_TEXT, WORK_RESULTS_FILE,
    WORK_SELF_SCORE
) = range(40, 47)

# ==================== Work States (Employee) - New (Unified) ====================
(
    WORK_KNOWLEDGE_ENTRY,
    WORK_SUGGESTION_ENTRY,
    WORK_RESULTS_ENTRY,
    WORK_SELF_SCORE_ENTRY
) = range(100, 104)

# ==================== Admin Review States ====================
(
    ADMIN_REVIEW_OPINION_TEXT, ADMIN_REVIEW_OPINION_FILE,
    ADMIN_REVIEW_POSITIVE_TEXT, ADMIN_REVIEW_POSITIVE_FILE,
    ADMIN_REVIEW_NEGATIVE_TEXT, ADMIN_REVIEW_NEGATIVE_FILE,
    ADMIN_REVIEW_SUGGESTION_TEXT, ADMIN_REVIEW_SUGGESTION_FILE,
    ADMIN_TASK_SCORE
) = range(50, 59)

# ==================== Task Status Constants ====================
TASK_STATUS_PENDING = 'pending'
TASK_STATUS_IN_PROGRESS = 'in_progress'
TASK_STATUS_COMPLETED = 'completed'
TASK_STATUS_ON_HOLD = 'on_hold'
TASK_STATUS_ARCHIVED = 'archived'

# ==================== User Role Constants ====================
ROLE_ADMIN = 'admin'
ROLE_EMPLOYEE = 'employee'
ROLE_PENDING = 'pending'

# ==================== Work Data Types ====================
DATA_TYPE_KNOWLEDGE = 'knowledge'
DATA_TYPE_SUGGESTION = 'suggestion'
DATA_TYPE_RESULTS = 'results'

# ==================== Review Types ====================
REVIEW_TYPE_OPINION = 'opinion'
REVIEW_TYPE_POSITIVE = 'positive'
REVIEW_TYPE_NEGATIVE = 'negative'
REVIEW_TYPE_SUGGESTION = 'suggestion'
REVIEW_TYPE_SCORE = 'score'

# ==================== File Types ====================
FILE_TYPE_PHOTO = 'photo'
FILE_TYPE_VIDEO = 'video'
FILE_TYPE_VOICE = 'voice'
FILE_TYPE_DOCUMENT = 'document'

# ==================== Section Types ====================
SECTION_TYPE_RESULTS = 'results'
SECTION_TYPE_DESCRIPTION = 'description'

<a id='utils_formatters_py'></a>
==================================================
# Ø¨Ø®Ø´ 41: utils\formatters.py
==================================================

# utils/formatters.py

"""
ØªÙˆØ§Ø¨Ø¹ ÙØ±Ù…Øªâ€ŒØ¨Ù†Ø¯ÛŒ Ùˆ Ù†Ù…Ø§ÛŒØ´
"""


def format_time(minutes: int) -> str:
    """
    ØªØ¨Ø¯ÛŒÙ„ Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¨Ù‡ ÙØ±Ù…Øª Ø³Ø§Ø¹Øª:Ø¯Ù‚ÛŒÙ‚Ù‡
    
    Args:
        minutes: ØªØ¹Ø¯Ø§Ø¯ Ø¯Ù‚Ø§ÛŒÙ‚
        
    Returns:
        str: ÙØ±Ù…Øª Ø´Ø¯Ù‡ (Ù…Ø«Ù„Ø§Ù‹ "2Ø³ 30Ø¯" ÛŒØ§ "45Ø¯")
    """
    if minutes < 60:
        return f"{minutes}Ø¯"
    hours = minutes // 60
    mins = minutes % 60
    return f"{hours}Ø³ {mins}Ø¯" if mins > 0 else f"{hours}Ø³"


def format_task_status(status: str) -> str:
    """
    ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø± Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´
    
    Args:
        status: ÙˆØ¶Ø¹ÛŒØª Ú©Ø§Ø±
        
    Returns:
        str: ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§ emoji
    """
    status_map = {
        'pending': 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±',
        'in_progress': 'ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ Ø§Ù†Ø¬Ø§Ù…',
        'completed': 'âœ… ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡',
        'on_hold': 'â¸ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡',
        'archived': 'ğŸ—„ Ø¢Ø±Ø´ÛŒÙˆ Ø´Ø¯Ù‡'
    }
    return status_map.get(status, 'Ù†Ø§Ù…Ø´Ø®Øµ')


def format_user_role(role: str, is_employee: int = 0) -> str:
    """
    ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ù†Ù‚Ø´ Ú©Ø§Ø±Ø¨Ø±
    
    Args:
        role: Ù†Ù‚Ø´ Ú©Ø§Ø±Ø¨Ø±
        is_employee: Ø¢ÛŒØ§ Ú©Ø§Ø±Ù…Ù†Ø¯ Ø§Ø³Øª
        
    Returns:
        str: Ù†Ù‚Ø´ Ø¨Ø§ emoji
    """
    if role == 'admin':
        return 'ğŸ‘¨â€ğŸ’¼ Ù…Ø¯ÛŒØ±'
    elif role == 'employee' and is_employee == 1:
        return 'ğŸ‘· Ú©Ø§Ø±Ù…Ù†Ø¯'
    elif role == 'pending':
        return 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÛŒÛŒØ¯'
    else:
        return 'Ù†Ø§Ù…Ø´Ø®Øµ'


def format_file_type(file_type: str) -> str:
    """
    ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ Ø¨Ø§ emoji
    
    Args:
        file_type: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„
        
    Returns:
        str: Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ Ø¨Ø§ emoji
    """
    file_type_map = {
        'photo': 'ğŸ–¼ ØªØµÙˆÛŒØ±',
        'video': 'ğŸ¥ ÙˆÛŒØ¯ÛŒÙˆ',
        'voice': 'ğŸ¤ ØµØ¯Ø§',
        'document': 'ğŸ“„ ÙØ§ÛŒÙ„'
    }
    return file_type_map.get(file_type, 'ğŸ“ ÙØ§ÛŒÙ„')


def truncate_text(text: str, max_length: int = 50) -> str:
    """
    Ú©ÙˆØªØ§Ù‡ Ú©Ø±Ø¯Ù† Ù…ØªÙ† Ø·ÙˆÙ„Ø§Ù†ÛŒ
    
    Args:
        text: Ù…ØªÙ† Ø§ØµÙ„ÛŒ
        max_length: Ø­Ø¯Ø§Ú©Ø«Ø± Ø·ÙˆÙ„
        
    Returns:
        str: Ù…ØªÙ† Ú©ÙˆØªØ§Ù‡ Ø´Ø¯Ù‡
    """
    if not text:
        return ""
    
    if len(text) <= max_length:
        return text
    
    return text[:max_length] + "..."


def format_date_persian(date_str: str) -> str:
    """
    ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† ØªØ§Ø±ÛŒØ® Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ§Ù†Ø§
    
    Args:
        date_str: ØªØ§Ø±ÛŒØ® Ø¨Ù‡ ÙØ±Ù…Øª "%Y-%m-%d %H:%M:%S"
        
    Returns:
        str: ØªØ§Ø±ÛŒØ® ÙØ±Ù…Øª Ø´Ø¯Ù‡
    """
    if not date_str:
        return "Ù†Ø¯Ø§Ø±Ø¯"
    
    try:
        # Ø¯Ø± Ø¢ÛŒÙ†Ø¯Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù† ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ ØªØ§Ø±ÛŒØ® Ø´Ù…Ø³ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯
        return date_str.split('.')[0]  # Ø­Ø°Ù microseconds
    except:
        return date_str


def format_score(score: int) -> str:
    """
    ÙØ±Ù…Øª Ú©Ø±Ø¯Ù† Ø§Ù…ØªÛŒØ§Ø²
    
    Args:
        score: Ø§Ù…ØªÛŒØ§Ø² (1-10)
        
    Returns:
        str: Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§ Ø³ØªØ§Ø±Ù‡
    """
    if not score:
        return "â­ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡"
    
    # ØªØ¨Ø¯ÛŒÙ„ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ø³ØªØ§Ø±Ù‡
    stars = "â­" * (score // 2)  # ØªÙ‚Ø³ÛŒÙ… Ø¨Ø± 2 Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¨Ù‡ØªØ±
    return f"{stars} {score}/10"


<a id='utils_keyboards_py'></a>
==================================================
# Ø¨Ø®Ø´ 42: utils\keyboards.py
==================================================

# utils/keyboards.py

"""
Ú©ÛŒØ¨ÙˆØ±Ø¯Ù‡Ø§ÛŒ Ù…Ø´ØªØ±Ú© Telegram
"""

from telegram import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton


# ==================== Reply Keyboards (Ø«Ø§Ø¨Øª) ====================

def get_admin_reply_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    keyboard = [[KeyboardButton("ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ")]]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


def get_employee_reply_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    keyboard = [[KeyboardButton("ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ")]]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


# ==================== Admin Keyboards ====================

def get_main_menu_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ Ø§Ø¯Ù…ÛŒÙ†"""
    keyboard = [
        [
            InlineKeyboardButton("â• ØªØ¹Ø±ÛŒÙ Ú©Ø§Ø±", callback_data="define_task"),
            InlineKeyboardButton("âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±", callback_data="edit_task")
        ],
        [
            InlineKeyboardButton("ğŸ“‹ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ù‡Ø§", callback_data="manage_tasks"),
            InlineKeyboardButton("ğŸ“‚ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§", callback_data="categories")
        ],
        [
            InlineKeyboardButton("âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡", callback_data="completed_tasks"),
            InlineKeyboardButton("ğŸ—„ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø®Ø§ØªÙ…Ù‡â€ŒÛŒØ§ÙØªÙ‡", callback_data="archived_tasks")
        ],
        [
            InlineKeyboardButton("ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", callback_data="user_management"),
            InlineKeyboardButton("ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡", callback_data="daily_report")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def get_back_to_menu_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ"""
    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data="back_to_main_menu")]]
    return InlineKeyboardMarkup(keyboard)


# ==================== Employee Keyboards ====================

def get_employee_main_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    keyboard = [
        [
            InlineKeyboardButton("ğŸ“ Ú©Ø§Ø±Ù‡Ø§", callback_data="list_tasks"),
            InlineKeyboardButton("ğŸ—‚ Ø¢Ø±Ø´ÛŒÙˆ Ú©Ø§Ø±Ù‡Ø§", callback_data="archive_tasks")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


def get_back_to_tasks_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ù‡Ø§"""
    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_tasks_list")]]
    return InlineKeyboardMarkup(keyboard)


def get_back_to_employee_menu_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ú©Ø§Ø±Ù…Ù†Ø¯"""
    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main_menu_employee")]]
    return InlineKeyboardMarkup(keyboard)


# ==================== Task Work Keyboards ====================

def get_task_work_keyboard(task_id, allocated_time, spent_time):
    """
    Ú©ÛŒØ¨ÙˆØ±Ø¯ Ù¾Ù†Ù„ Ú©Ø§Ø±
    
    Args:
        task_id: Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±
        allocated_time: Ø²Ù…Ø§Ù† ØªØ®ØµÛŒØµÛŒ (Ø¯Ù‚ÛŒÙ‚Ù‡)
        spent_time: Ø²Ù…Ø§Ù† Ø³Ù¾Ø±ÛŒ Ø´Ø¯Ù‡ (Ø¯Ù‚ÛŒÙ‚Ù‡)
    """
    from utils.formatters import format_time
    
    spent_formatted = format_time(spent_time)
    allocated_formatted = format_time(allocated_time) if allocated_time > 0 else "ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡"
    
    keyboard = [
        [InlineKeyboardButton("ğŸš€ Ø´Ø±ÙˆØ¹ Ú©Ø§Ø±", callback_data=f"start_work_{task_id}")],
        [
            InlineKeyboardButton(f"â±ï¸ Ø²Ù…Ø§Ù† Ú©Ù„: {allocated_formatted}", callback_data=f"work_panel_{task_id}"),
            InlineKeyboardButton(f"âŒš Ø²Ù…Ø§Ù† Ø³Ù¾Ø±ÛŒ Ø´Ø¯Ù‡: {spent_formatted}", callback_data=f"work_panel_{task_id}")
        ],
        [InlineKeyboardButton("ğŸ“š Ø«Ø¨Øª Ø¯Ø§Ù†Ø´", callback_data=f"knowledge_{task_id}")],
        [InlineKeyboardButton("ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯", callback_data=f"suggestion_{task_id}")],
        [InlineKeyboardButton("ğŸ“‹ Ù†ØªØ§ÛŒØ¬ Ú©Ø§Ø±", callback_data=f"results_{task_id}")],
        [InlineKeyboardButton("â­ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ Ø®ÙˆØ¯", callback_data=f"self_score_{task_id}")],
        [InlineKeyboardButton("âœ… ØªØ­ÙˆÛŒÙ„ Ú©Ø§Ø±", callback_data=f"submit_{task_id}")],
        [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_tasks_list")]
    ]
    return InlineKeyboardMarkup(keyboard)


# ==================== Phone Request Keyboard ====================

def get_phone_request_keyboard():
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†"""
    keyboard = [[KeyboardButton("ğŸ“± Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†", request_contact=True)]]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)


# ==================== Confirmation Keyboards ====================

def get_yes_no_keyboard(yes_callback, no_callback="cancel"):
    """Ú©ÛŒØ¨ÙˆØ±Ø¯ ØªØ£ÛŒÛŒØ¯/Ø±Ø¯"""
    keyboard = [
        [
            InlineKeyboardButton("âœ… Ø¨Ù„Ù‡", callback_data=yes_callback),
            InlineKeyboardButton("âŒ Ø®ÛŒØ±", callback_data=no_callback)
        ]
    ]
    return InlineKeyboardMarkup(keyboard)


<a id='utils_validators_py'></a>
==================================================
# Ø¨Ø®Ø´ 43: utils\validators.py
==================================================

# utils/validators.py

"""
ØªÙˆØ§Ø¨Ø¹ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ
"""

import re


def validate_full_name(name: str) -> tuple[bool, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù†Ø§Ù… Ú©Ø§Ù…Ù„
    
    Args:
        name: Ù†Ø§Ù… Ú©Ø§Ù…Ù„
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    name = name.strip()
    
    if not name:
        return False, "âŒ Ù†Ø§Ù… Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯!"
    
    if len(name.split()) < 2:
        return False, "âŒ Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n\nÙ…Ø«Ø§Ù„: Ø¹Ù„ÛŒ Ø§Ø­Ù…Ø¯ÛŒ"
    
    return True, ""


def validate_phone_number(phone: str) -> tuple[bool, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†
    
    Args:
        phone: Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    if not phone:
        return False, "âŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª!"
    
    # Ø­Ø°Ù ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ Ùˆ Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
    phone = phone.replace(" ", "").replace("-", "").replace("+", "")
    
    # Ø¨Ø±Ø±Ø³ÛŒ Ø·ÙˆÙ„ (Ø´Ù…Ø§Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÛŒØ±Ø§Ù†ÛŒ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ 10 ÛŒØ§ 11 Ø±Ù‚Ù…ÛŒ Ù‡Ø³ØªÙ†Ø¯)
    if len(phone) < 10:
        return False, "âŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª!"
    
    return True, ""


def validate_score(score: str) -> tuple[bool, int, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø§Ù…ØªÛŒØ§Ø²
    
    Args:
        score: Ø§Ù…ØªÛŒØ§Ø² Ø¨Ù‡ ØµÙˆØ±Øª Ø±Ø´ØªÙ‡
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ø¹Ø¯Ø¯ Ø§Ù…ØªÛŒØ§Ø², Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    try:
        score_int = int(score)
        
        if score_int < 1 or score_int > 10:
            return False, 0, "âŒ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 1 ØªØ§ 10 Ø¨Ø§Ø´Ø¯!"
        
        return True, score_int, ""
    
    except ValueError:
        return False, 0, "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯!"


def validate_duration(duration: str) -> tuple[bool, int, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…Ø¯Øª Ø²Ù…Ø§Ù† (Ø¯Ù‚ÛŒÙ‚Ù‡)
    
    Args:
        duration: Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¨Ù‡ ØµÙˆØ±Øª Ø±Ø´ØªÙ‡
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ø¹Ø¯Ø¯ Ø¯Ù‚ÛŒÙ‚Ù‡, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    try:
        duration_int = int(duration)
        
        if duration_int < 1:
            return False, 0, "âŒ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯!"
        
        if duration_int > 10000:
            return False, 0, "âŒ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø®ÛŒÙ„ÛŒ Ø²ÛŒØ§Ø¯ Ø§Ø³Øª!"
        
        return True, duration_int, ""
    
    except ValueError:
        return False, 0, "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯!"


def validate_importance(importance: str) -> tuple[bool, int, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø§Ù‡Ù…ÛŒØª
    
    Args:
        importance: Ø§Ù‡Ù…ÛŒØª Ø¨Ù‡ ØµÙˆØ±Øª Ø±Ø´ØªÙ‡
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ø¹Ø¯Ø¯ Ø§Ù‡Ù…ÛŒØª, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    try:
        importance_int = int(importance)
        
        if importance_int < 1 or importance_int > 10:
            return False, 0, "âŒ Ø§Ù‡Ù…ÛŒØª Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 1 ØªØ§ 10 Ø¨Ø§Ø´Ø¯!"
        
        return True, importance_int, ""
    
    except ValueError:
        return False, 0, "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯!"


def validate_priority(priority: str) -> tuple[bool, int, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø§ÙˆÙ„ÙˆÛŒØª
    
    Args:
        priority: Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ù‡ ØµÙˆØ±Øª Ø±Ø´ØªÙ‡
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ø¹Ø¯Ø¯ Ø§ÙˆÙ„ÙˆÛŒØª, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    try:
        priority_int = int(priority)
        
        if priority_int < 1 or priority_int > 10:
            return False, 0, "âŒ Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 1 ØªØ§ 10 Ø¨Ø§Ø´Ø¯!"
        
        return True, priority_int, ""
    
    except ValueError:
        return False, 0, "âŒ Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø¹Ø¯Ø¯ Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯!"


def validate_category_name(name: str) -> tuple[bool, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ
    
    Args:
        name: Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    name = name.strip()
    
    if not name:
        return False, "âŒ Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯!"
    
    if len(name) < 2:
        return False, "âŒ Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 2 Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯!"
    
    if len(name) > 50:
        return False, "âŒ Ù†Ø§Ù… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø®ÛŒÙ„ÛŒ Ø·ÙˆÙ„Ø§Ù†ÛŒ Ø§Ø³Øª! (Ø­Ø¯Ø§Ú©Ø«Ø± 50 Ú©Ø§Ø±Ø§Ú©ØªØ±)"
    
    return True, ""


def validate_text_input(text: str, min_length: int = 1, max_length: int = 5000) -> tuple[bool, str]:
    """
    Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù…ØªÙ†ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ
    
    Args:
        text: Ù…ØªÙ† ÙˆØ±ÙˆØ¯ÛŒ
        min_length: Ø­Ø¯Ø§Ù‚Ù„ Ø·ÙˆÙ„
        max_length: Ø­Ø¯Ø§Ú©Ø«Ø± Ø·ÙˆÙ„
        
    Returns:
        tuple: (Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª, Ù¾ÛŒØ§Ù… Ø®Ø·Ø§)
    """
    text = text.strip()
    
    if not text:
        return False, "âŒ Ù…ØªÙ† Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯!"
    
    if len(text) < min_length:
        return False, f"âŒ Ù…ØªÙ† Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ {min_length} Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯!"
    
    if len(text) > max_length:
        return False, f"âŒ Ù…ØªÙ† Ø®ÛŒÙ„ÛŒ Ø·ÙˆÙ„Ø§Ù†ÛŒ Ø§Ø³Øª! (Ø­Ø¯Ø§Ú©Ø«Ø± {max_length} Ú©Ø§Ø±Ø§Ú©ØªØ±)"
    
    return True, ""


<a id='utils___init___py'></a>
==================================================
# Ø¨Ø®Ø´ 44: utils\__init__.py
==================================================

# utils/__init__.py

from utils.constants import *
from utils.keyboards import *
from utils.formatters import *
from utils.validators import *

__all__ = [
    # Constants
    'GET_FULL_NAME', 'GET_PHONE',
    'TASK_START_CONFIRMATION', 'TASK_WORK_VIEW',
    'GET_CATEGORY_NAME',
    'AWAITING_CONFIRMATION',
    'WORK_KNOWLEDGE_TEXT', 'WORK_KNOWLEDGE_FILE',
    'WORK_SUGGESTION_TEXT', 'WORK_SUGGESTION_FILE',
    'WORK_RESULTS_TEXT', 'WORK_RESULTS_FILE',
    'WORK_SELF_SCORE',
    'ADMIN_REVIEW_OPINION_TEXT', 'ADMIN_REVIEW_OPINION_FILE',
    'ADMIN_REVIEW_POSITIVE_TEXT', 'ADMIN_REVIEW_POSITIVE_FILE',
    'ADMIN_REVIEW_NEGATIVE_TEXT', 'ADMIN_REVIEW_NEGATIVE_FILE',
    'ADMIN_REVIEW_SUGGESTION_TEXT', 'ADMIN_REVIEW_SUGGESTION_FILE',
    'ADMIN_TASK_SCORE',
    
    # Keyboards
    'get_admin_reply_keyboard',
    'get_employee_reply_keyboard',
    'get_main_menu_keyboard',
    'get_employee_main_keyboard',
    'get_task_work_keyboard',
    
    # Formatters
    'format_time',
    'format_task_status',
    'format_user_role',
    
    # Validators
    'validate_full_name',
    'validate_score',
    'validate_duration',
]
